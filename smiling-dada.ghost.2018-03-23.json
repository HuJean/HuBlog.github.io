{"db":[{"meta":{"exported_on":1521767332967,"version":"009"},"data":{"posts":[{"id":1,"uuid":"3397b788-ea3f-453f-a9f5-03dc742bdfff","title":"前端路线","slug":"welcome-to-ghost","markdown":"![](/assets/images/2017/web-------1.png)","mobiledoc":null,"html":"<p><img src=\"/assets/images/2017/web-------1.png\" alt=\"\" /></p>","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-25 07:00:36","updated_by":1,"published_at":"2017-05-18 01:49:49","published_by":1},{"id":2,"uuid":"5ec547a5-725e-40a3-81f7-432ad9ae61c0","title":"CSS--基础","slug":"css-ji-chu","markdown":"####盒子模型\n * W3C盒子模型：内容(content)、填充(padding)、边界(margin)、 边框(border)。![The W3C Box](/assets/images/2017/box_W3C.jpg)\n * IE盒子模型：content部分把 border 和 padding计算了进去。![The IE Box](/assets/images/2017/box_IE.jpg)\n\n---\n####选择符\n * id选择器（ # myid）\n * 类选择器（.myclassname）\n * 标签选择器（div, h1, p）\n * 相邻选择器（h1 + p）\n * 子选择器（ul > li）\n * 后代选择器（li a）\n * 通配符选择器（ * ）\n * 属性选择器（a[rel = \"external\"]）\n * 伪类选择器（a:hover, li:nth-child）\n * 可继承的样式： font-size font-family color, UL LI DL DD DT\n * 不可继承的样式：border padding margin width height \n\n\n---\n####优先级算法\n * 权重：内联样式表（标签内部）>嵌入样式表（当前文件中）>外部样式表（外部文件中），!important>id>class>tag，important比内联优先级高。\n * 优先级就近原则，同权重情况下样式定义最近者为准，载入样式以最后载入的定位为准。![The IE Box](/assets/images/2017/priority.JPG)\n\n---\n####伪类及伪元素\n * 伪类：用于向某些选择器添加特殊的效果\n * 伪元素：用于将特殊的效果添加到某些选择器![The IE Box](/assets/images/2017/class_ele.jpg)\n\n---","mobiledoc":null,"html":"<h4 id=\"\">盒子模型</h4>\n\n<ul>\n<li>W3C盒子模型：内容(content)、填充(padding)、边界(margin)、 边框(border)。<img src=\"/assets/images/2017/box_W3C.jpg\" alt=\"The W3C Box\" title=\"\" /></li>\n<li>IE盒子模型：content部分把 border 和 padding计算了进去。<img src=\"/assets/images/2017/box_IE.jpg\" alt=\"The IE Box\" title=\"\" /></li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">选择符</h4>\n\n<ul>\n<li>id选择器（ # myid）</li>\n<li>类选择器（.myclassname）</li>\n<li>标签选择器（div, h1, p）</li>\n<li>相邻选择器（h1 + p）</li>\n<li>子选择器（ul > li）</li>\n<li>后代选择器（li a）</li>\n<li>通配符选择器（ * ）</li>\n<li>属性选择器（a[rel = \"external\"]）</li>\n<li>伪类选择器（a:hover, li:nth-child）</li>\n<li>可继承的样式： font-size font-family color, UL LI DL DD DT</li>\n<li>不可继承的样式：border padding margin width height </li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">优先级算法</h4>\n\n<ul>\n<li>权重：内联样式表（标签内部）>嵌入样式表（当前文件中）>外部样式表（外部文件中），!important>id>class>tag，important比内联优先级高。</li>\n<li>优先级就近原则，同权重情况下样式定义最近者为准，载入样式以最后载入的定位为准。<img src=\"/assets/images/2017/priority.JPG\" alt=\"The IE Box\" title=\"\" /></li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">伪类及伪元素</h4>\n\n<ul>\n<li>伪类：用于向某些选择器添加特殊的效果</li>\n<li>伪元素：用于将特殊的效果添加到某些选择器<img src=\"/assets/images/2017/class_ele.jpg\" alt=\"The IE Box\" title=\"\" /></li>\n</ul>\n\n<hr />","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-18 02:06:53","created_by":1,"updated_at":"2017-05-18 02:45:57","updated_by":1,"published_at":"2017-05-18 02:40:03","published_by":1},{"id":3,"uuid":"6dc0c205-2ee1-4d76-a210-a62f2b92aefc","title":"CSS--Float","slug":"css-floatfu-dong","markdown":"\n####浮动的理解\n* 浮动可以理解为让某个div元素脱离标准流，漂浮在标准流之上，和标准流不是一个层次。\n * 首先，在页面上安置标准流元素；\n * 假如某个div元素A是浮动的，如果A元素上一个元素也是浮动的，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；\n * 如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。\n * 元素浮动之前，也就是在标准流中，是竖向排列的，而浮动之后可以理解为横向排列。\n\n---\n####效果\n * 块状元素，会钻进浮动元素的下面，被浮动元素所覆盖![](/assets/images/2017/float_1.jpg)\n * 行内元素，例如文字，则会环绕在浮动元素的周围，为浮动元素留出空间![](/assets/images/2017/float_2.jpg)\n * 浮动元素的父元素坍缩![](/assets/images/2017/float_3.jpg)\n\n---\n####清除浮动的基本方法\n * clear : none | left | right | both\n  * none：默认值，允许两边都可以有浮动对象；\n  * left：不允许左边有浮动对象；\n  * right：不允许右边有浮动对象；\n  * both：不允许有浮动对象。\n * 对于CSS的清除浮动(clear)，一定要牢记：这个规则只能影响使用清除的元素本身，不能影响其他元素。希望移动那个元素，就要在那个元素中添加清除浮动。\n\n---\n####闭合浮动\n * 使浮动元素闭合，从而减少浮动带来的影响\n  * 添加额外标签：在浮动元素末尾添加一个空的标签例如div style=\"clear:both\"；有违结构与表现分离；\n  * 使用 br标签和其自身的 html属性，br 有 clear=“all | left | right | none” 属性\n  * 父元素设置 overflow：hidden；内容增多时候容易造成不会自动换行导致内容被隐藏掉\n  * 父元素也设置浮动，使得与父元素相邻的元素的布局会受到影响，不可能一直浮动到body\n  * 使用:after 伪元素\n * 通过对比，我们不难发现，其实以上列举的方法，无非有两类：其一，通过在浮动元素的末尾添加一个空元素，设置 clear：both属性，after伪元素其实也是通过 content 在元素的后面生成了内容为一个点的块级元素；其二，通过设置父元素 overflow 或者display：table 属性来闭合浮动。\n\n---\n\n\n","mobiledoc":null,"html":"<h4 id=\"\">浮动的理解</h4>\n\n<ul>\n<li>浮动可以理解为让某个div元素脱离标准流，漂浮在标准流之上，和标准流不是一个层次。\n<ul><li>首先，在页面上安置标准流元素；</li>\n<li>假如某个div元素A是浮动的，如果A元素上一个元素也是浮动的，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；</li>\n<li>如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。</li>\n<li>元素浮动之前，也就是在标准流中，是竖向排列的，而浮动之后可以理解为横向排列。</li></ul></li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">效果</h4>\n\n<ul>\n<li>块状元素，会钻进浮动元素的下面，被浮动元素所覆盖<img src=\"/assets/images/2017/float_1.jpg\" alt=\"\" title=\"\" /></li>\n<li>行内元素，例如文字，则会环绕在浮动元素的周围，为浮动元素留出空间<img src=\"/assets/images/2017/float_2.jpg\" alt=\"\" title=\"\" /></li>\n<li>浮动元素的父元素坍缩<img src=\"/assets/images/2017/float_3.jpg\" alt=\"\" title=\"\" /></li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">清除浮动的基本方法</h4>\n\n<ul>\n<li>clear : none | left | right | both\n<ul><li>none：默认值，允许两边都可以有浮动对象；</li>\n<li>left：不允许左边有浮动对象；</li>\n<li>right：不允许右边有浮动对象；</li>\n<li>both：不允许有浮动对象。</li></ul></li>\n<li>对于CSS的清除浮动(clear)，一定要牢记：这个规则只能影响使用清除的元素本身，不能影响其他元素。希望移动那个元素，就要在那个元素中添加清除浮动。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">闭合浮动</h4>\n\n<ul>\n<li>使浮动元素闭合，从而减少浮动带来的影响\n<ul><li>添加额外标签：在浮动元素末尾添加一个空的标签例如div style=\"clear:both\"；有违结构与表现分离；</li>\n<li>使用 br标签和其自身的 html属性，br 有 clear=“all | left | right | none” 属性</li>\n<li>父元素设置 overflow：hidden；内容增多时候容易造成不会自动换行导致内容被隐藏掉</li>\n<li>父元素也设置浮动，使得与父元素相邻的元素的布局会受到影响，不可能一直浮动到body</li>\n<li>使用:after 伪元素</li></ul></li>\n<li>通过对比，我们不难发现，其实以上列举的方法，无非有两类：其一，通过在浮动元素的末尾添加一个空元素，设置 clear：both属性，after伪元素其实也是通过 content 在元素的后面生成了内容为一个点的块级元素；其二，通过设置父元素 overflow 或者display：table 属性来闭合浮动。</li>\n</ul>\n\n<hr />","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-18 02:41:00","created_by":1,"updated_at":"2017-05-18 03:09:02","updated_by":1,"published_at":"2017-05-18 03:09:02","published_by":1},{"id":4,"uuid":"2577f229-d9fc-462d-85e8-68dfb2c90577","title":"CSS--BFC","slug":"css-bfc","markdown":"####BFC(Block formatting context)\n* 直译为\"块级格式化上下文\"。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。\n* 生成元素\n * 根元素\n * float属性不为none\n * position为absolute或fixed\n * display为inline-block, table-cell, table-caption, flex, inline-flex\n * overflow不为visible\n\n---\n####Box\n* CSS布局的基本单位，元素的类型和 display 属性，决定了这个 Box 的类型。\n* 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。\n * block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；\n * inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；\n * run-in box: css3 中才有， 这儿先不讲了。\n* Formatting Context：一个决定如何渲染文档的容器，它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。\n\n---\n####BFC布局规则\n* 内部的Box会在垂直方向，一个接一个地放置。\n* Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠\n* 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n* BFC的区域不会与float box重叠。\n* BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n* 计算BFC的高度时，浮动元素也参与计算\n\n---\n####BFC作用及原理\n* 自适应两栏布局 float: left; overflow: hidden;\n* 清除内部浮动 overflow: hidden;\n* 防止垂直 margin 重叠 \n* 因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。\n\n---\n####Margin垂直塌陷\n* 当两个块框上下毗邻时，两者之间的margin会塌陷并尺寸值取较大的那个外边距。  \n当两个块级框是父子关系时，也会在垂直方向发生margin塌陷，取值依然是较大的那个。\n* 块级框自身发生collapce现象：即当垂直padding和height为零时，上下外边距会发生塌陷\n* 解决方案\n * 为父盒子设置border，为外层添加border后父子盒子就不是真正意义上的贴合。\n * 为父盒子添加overflow：hidden；\n * 为父盒子设定padding值；添加空div清理浮动；利用clear属性清除浮动或者使父容器形成BFC。\n\n\n---\n\n\n\n","mobiledoc":null,"html":"<h4 id=\"bfcblockformattingcontext\">BFC(Block formatting context)</h4>\n\n<ul>\n<li>直译为\"块级格式化上下文\"。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</li>\n<li>生成元素\n<ul><li>根元素</li>\n<li>float属性不为none</li>\n<li>position为absolute或fixed</li>\n<li>display为inline-block, table-cell, table-caption, flex, inline-flex</li>\n<li>overflow不为visible</li></ul></li>\n</ul>\n\n<hr />\n\n<h4 id=\"box\">Box</h4>\n\n<ul>\n<li>CSS布局的基本单位，元素的类型和 display 属性，决定了这个 Box 的类型。</li>\n<li>不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。\n<ul><li>block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</li>\n<li>inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；</li>\n<li>run-in box: css3 中才有， 这儿先不讲了。</li></ul></li>\n<li>Formatting Context：一个决定如何渲染文档的容器，它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"bfc\">BFC布局规则</h4>\n\n<ul>\n<li>内部的Box会在垂直方向，一个接一个地放置。</li>\n<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>\n<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>\n<li>BFC的区域不会与float box重叠。</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>\n<li>计算BFC的高度时，浮动元素也参与计算</li>\n</ul>\n\n<hr />\n\n<h4 id=\"bfc\">BFC作用及原理</h4>\n\n<ul>\n<li>自适应两栏布局 float: left; overflow: hidden;</li>\n<li>清除内部浮动 overflow: hidden;</li>\n<li>防止垂直 margin 重叠 </li>\n<li>因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"margin\">Margin垂直塌陷</h4>\n\n<ul>\n<li>当两个块框上下毗邻时，两者之间的margin会塌陷并尺寸值取较大的那个外边距。 <br />\n当两个块级框是父子关系时，也会在垂直方向发生margin塌陷，取值依然是较大的那个。</li>\n<li>块级框自身发生collapce现象：即当垂直padding和height为零时，上下外边距会发生塌陷</li>\n<li>解决方案\n<ul><li>为父盒子设置border，为外层添加border后父子盒子就不是真正意义上的贴合。</li>\n<li>为父盒子添加overflow：hidden；</li>\n<li>为父盒子设定padding值；添加空div清理浮动；利用clear属性清除浮动或者使父容器形成BFC。</li></ul></li>\n</ul>\n\n<hr />","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-18 03:10:06","created_by":1,"updated_at":"2017-05-18 06:55:31","updated_by":1,"published_at":"2017-05-18 06:55:31","published_by":1},{"id":5,"uuid":"e4120d72-b726-42f1-8b1f-c355a9f17d8e","title":"CSS--Layout","slug":"css-layout","markdown":"####两栏布局（左边宽度固定，右边自动适应）\n* 左浮动其中一个DIV，使其脱离文档流，另一个DIV不设置浮动即可。设置浮动可以让元素脱离正常的文档流，使后面的元素占据浮动元素本身的位置。但是浮动元素只能影响后面的元素的位置，而不能够影响前面的元素，也不能叠加在前面的元素上。![](/assets/images/2017/layout_1.jpg)\n* 使用绝对定位方法，是固定宽度的DIV固定在左侧，然后设置自适应的层的左边距。![](/assets/images/2017/layout_2.jpg)\n* 增加一个浮动层，设置宽度为100%，包裹中的自适应宽度层设置左边距，然后控制固定宽度的层的负外边距(不兼容IE6)![](/assets/images/2017/layout_3-1.jpg)\n\n---\n####三栏布局（左右宽度固定，中间自适应宽度）\n* 设置浮动，使文档脱离文档流，注意层的顺序![](/assets/images/2017/layout_4.jpg)\n* 同样通过负边距来实现，缺点是需要另外增加一个层![](/assets/images/2017/layout_5.jpg)\n* 也可以通过绝对定位来实现![](/assets/images/2017/layout_6.jpg)\n\n---\n####三栏布局（左右自适应，中间宽度固定）\n* 这个有点变态，一般没这么布局的![](/assets/images/2017/layout_7.jpg)\n\n---\n####居中\n* 水平居中\n * 子元素是块级元素且宽度没有设定：在这种情况下，实际上也不存在水平居中一说，因为子元素是块级元素没有设定宽度，那么它会充满整个父级元素的宽度，即在水平位置上宽度和父元素一致\n * 子元素是行内元素，子元素宽度是由其内容撑开的：给父元素设定text-align:center;\n * 子元素是块级元素且宽度已经设定\n  > * 给子元素添加margin:0 auto; 上下边界为0，左右则根据宽度自适应；\n  > * 通过计算指定父元素的padding-left或padding-right\n  > * 计算得到子元素的margin-left或margin-right\n  > * 通过子元素相对父元素绝对定位 box-sizing: border-box; 宽度就是包含border+padding+content\n  > * 利用flex-box                     \n  ![](/assets/images/2017/layout_8.jpg)\n\n* 垂直居中\n * 子元素是行内元素，高度是由其内容撑开的：设定父元素的line-height为其高度来使得子元素垂直居中；\n * 子元素是块级元素但是子元素高度没有设定，在这种情况下实际上是不知道子元素的高度的，无法通过计算得到padding或margin来调整\n  > * 通过给父元素设定display:table-cell;vertical-align:middle来解决\n  > * flexbox   \n ![](/assets/images/2017/layout_10.jpg)\n \n * 子元素是块级元素且高度已经设定\n  > * 计算子元素的margin-top或margin-bottom，计算方法为父(元素高度-子元素高度)/2\n  > * 计算父元素的padding-top或padding-bottom，计算方法为(父元素高度-子元素高度)/2\n  > * 利用绝对定位，让子元素相对于父元素绝对定位\n  > * 利用flexbox  \n ![](/assets/images/2017/layout_11.jpg)\n\n---\n####flex-flow 详解\n* 弹性布局是CSS3引入的强大的布局方式\n* 父类属性\n * flex-direction：排列方向row | row-reverse | column | column-reverse;\n * flex-wrap：子项在容器内的换行效果nowrap | wrap | wrap-reverse;\n * justify-content：子项在容器内水平对齐方式flex-start | flex-end | center | space-between | space-around;\n * align-items：子项在容器内垂直对齐方式flex-start | flex-end | center | baseline | stretch;\n * align-content：多行子项在容器内整体垂直对齐方式flex-start | flex-end | center | space-between | space-around | stretch;\n* 子类属性\n * Order：子项们的排列顺序\n * flex-grow：子项宽度之和不足父元素宽度时，子项拉伸的比例\n * flex-shrink：子项宽度之和超过父元素宽度时，子项缩放的比例\n * flex-basis：子项的初始宽度，若子项宽度之和超过父元素宽度时，子项按照flex-basis的比例缩放\n * align-self：单个子项与其他项目不一样的对齐方式\n\n---\n####position 定位\n* static：取消覆盖之前的定位（position的默认值）\n* relative：相对定位，仍然占据原来的位置\n * 元素设置了relative时，是相对于元素本身位置进行定位\n * 元素设置了relative后，可以通过“T-R-B-L”改变元素当前所在的位置，但元素移位后，同样点有当初的物理空间位；\n * 元素设置了relative后，如果没有进行任何的“T-R-B-L”设置，元素不会进行任何位置改变。\n* absolute：绝对定位\n * 给元素指定了absolute，整个元素就会漂出文档流，而且元素自身的物理空间也同时消失了。\n * 绝对定位元素的任何祖先元素没有进行任何的“relative”或者“absolute”设置，那么绝对定位的元素的参考物就是html”\n * 页面中的其他元素位置也发生了变化。\n* relative和absolute的结合：如果一个元素绝对定位后，其参照物是以离自身最近元素是否设置了相对定位，如果有设置将以离自己最近元素定位，如果没有将往其祖先元素寻找相对定位元素，一直找到html为止。\n* relative和absolute实现布局效果\n* 设置固定高度\n* Float浮动（高度自适应）\n* 多列浮动\n* 清除浮动\n\n---\n","mobiledoc":null,"html":"<h4 id=\"\">两栏布局（左边宽度固定，右边自动适应）</h4>\n\n<ul>\n<li>左浮动其中一个DIV，使其脱离文档流，另一个DIV不设置浮动即可。设置浮动可以让元素脱离正常的文档流，使后面的元素占据浮动元素本身的位置。但是浮动元素只能影响后面的元素的位置，而不能够影响前面的元素，也不能叠加在前面的元素上。<img src=\"/assets/images/2017/layout_1.jpg\" alt=\"\" title=\"\" /></li>\n<li>使用绝对定位方法，是固定宽度的DIV固定在左侧，然后设置自适应的层的左边距。<img src=\"/assets/images/2017/layout_2.jpg\" alt=\"\" title=\"\" /></li>\n<li>增加一个浮动层，设置宽度为100%，包裹中的自适应宽度层设置左边距，然后控制固定宽度的层的负外边距(不兼容IE6)<img src=\"/assets/images/2017/layout_3-1.jpg\" alt=\"\" title=\"\" /></li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">三栏布局（左右宽度固定，中间自适应宽度）</h4>\n\n<ul>\n<li>设置浮动，使文档脱离文档流，注意层的顺序<img src=\"/assets/images/2017/layout_4.jpg\" alt=\"\" title=\"\" /></li>\n<li>同样通过负边距来实现，缺点是需要另外增加一个层<img src=\"/assets/images/2017/layout_5.jpg\" alt=\"\" title=\"\" /></li>\n<li>也可以通过绝对定位来实现<img src=\"/assets/images/2017/layout_6.jpg\" alt=\"\" title=\"\" /></li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">三栏布局（左右自适应，中间宽度固定）</h4>\n\n<ul>\n<li>这个有点变态，一般没这么布局的<img src=\"/assets/images/2017/layout_7.jpg\" alt=\"\" title=\"\" /></li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">居中</h4>\n\n<ul>\n<li><p>水平居中\n<ul><li>子元素是块级元素且宽度没有设定：在这种情况下，实际上也不存在水平居中一说，因为子元素是块级元素没有设定宽度，那么它会充满整个父级元素的宽度，即在水平位置上宽度和父元素一致</li>\n<li>子元素是行内元素，子元素宽度是由其内容撑开的：给父元素设定text-align:center;</li>\n<li>子元素是块级元素且宽度已经设定</p>\n\n<blockquote>\n  <ul><li>给子元素添加margin:0 auto; 上下边界为0，左右则根据宽度自适应；</li>\n  <li>通过计算指定父元素的padding-left或padding-right</li>\n  <li>计算得到子元素的margin-left或margin-right</li>\n  <li>通过子元素相对父元素绝对定位 box-sizing: border-box; 宽度就是包含border+padding+content</li>\n  <li>利用flex-box <br />\n  <img src=\"/assets/images/2017/layout_8.jpg\" alt=\"\" title=\"\" /></li></ul></li></ul>\n</blockquote></li>\n<li><p>垂直居中</p>\n\n<ul><li>子元素是行内元素，高度是由其内容撑开的：设定父元素的line-height为其高度来使得子元素垂直居中；</li>\n<li><p>子元素是块级元素但是子元素高度没有设定，在这种情况下实际上是不知道子元素的高度的，无法通过计算得到padding或margin来调整</p>\n\n<blockquote>\n  <ul><li>通过给父元素设定display:table-cell;vertical-align:middle来解决</li>\n  <li>flexbox <br />\n  <img src=\"/assets/images/2017/layout_10.jpg\" alt=\"\" title=\"\" /></li></ul>\n\n<p></blockquote></li>\n<li><p>子元素是块级元素且高度已经设定</p></p>\n\n<p><blockquote>\n  <ul><li>计算子元素的margin-top或margin-bottom，计算方法为父(元素高度-子元素高度)/2</li>\n  <li>计算父元素的padding-top或padding-bottom，计算方法为(父元素高度-子元素高度)/2</li>\n  <li>利用绝对定位，让子元素相对于父元素绝对定位</li>\n  <li>利用flexbox <br />\n  <img src=\"/assets/images/2017/layout_11.jpg\" alt=\"\" title=\"\" /></li></ul>\n</blockquote></li></ul></p></li>\n</ul>\n\n<hr />\n\n<h4 id=\"flexflow\">flex-flow 详解</h4>\n\n<ul>\n<li>弹性布局是CSS3引入的强大的布局方式</li>\n<li>父类属性\n<ul><li>flex-direction：排列方向row | row-reverse | column | column-reverse;</li>\n<li>flex-wrap：子项在容器内的换行效果nowrap | wrap | wrap-reverse;</li>\n<li>justify-content：子项在容器内水平对齐方式flex-start | flex-end | center | space-between | space-around;</li>\n<li>align-items：子项在容器内垂直对齐方式flex-start | flex-end | center | baseline | stretch;</li>\n<li>align-content：多行子项在容器内整体垂直对齐方式flex-start | flex-end | center | space-between | space-around | stretch;</li></ul></li>\n<li>子类属性\n<ul><li>Order：子项们的排列顺序</li>\n<li>flex-grow：子项宽度之和不足父元素宽度时，子项拉伸的比例</li>\n<li>flex-shrink：子项宽度之和超过父元素宽度时，子项缩放的比例</li>\n<li>flex-basis：子项的初始宽度，若子项宽度之和超过父元素宽度时，子项按照flex-basis的比例缩放</li>\n<li>align-self：单个子项与其他项目不一样的对齐方式</li></ul></li>\n</ul>\n\n<hr />\n\n<h4 id=\"position\">position 定位</h4>\n\n<ul>\n<li>static：取消覆盖之前的定位（position的默认值）</li>\n<li>relative：相对定位，仍然占据原来的位置\n<ul><li>元素设置了relative时，是相对于元素本身位置进行定位</li>\n<li>元素设置了relative后，可以通过“T-R-B-L”改变元素当前所在的位置，但元素移位后，同样点有当初的物理空间位；</li>\n<li>元素设置了relative后，如果没有进行任何的“T-R-B-L”设置，元素不会进行任何位置改变。</li></ul></li>\n<li>absolute：绝对定位\n<ul><li>给元素指定了absolute，整个元素就会漂出文档流，而且元素自身的物理空间也同时消失了。</li>\n<li>绝对定位元素的任何祖先元素没有进行任何的“relative”或者“absolute”设置，那么绝对定位的元素的参考物就是html”</li>\n<li>页面中的其他元素位置也发生了变化。</li></ul></li>\n<li>relative和absolute的结合：如果一个元素绝对定位后，其参照物是以离自身最近元素是否设置了相对定位，如果有设置将以离自己最近元素定位，如果没有将往其祖先元素寻找相对定位元素，一直找到html为止。</li>\n<li>relative和absolute实现布局效果</li>\n<li>设置固定高度</li>\n<li>Float浮动（高度自适应）</li>\n<li>多列浮动</li>\n<li>清除浮动</li>\n</ul>\n\n<hr />","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-18 03:10:20","created_by":1,"updated_at":"2017-05-18 06:54:17","updated_by":1,"published_at":"2017-05-18 06:54:17","published_by":1},{"id":6,"uuid":"31a9c254-a851-41aa-b7a8-c6615961a451","title":"CSS--Draw","slug":"css-animation","markdown":"####优劣\n利用css画图形，是个有利有弊的写法，好处是不用画图，且节省了一些流量，坏处是要写长串的css样式，而且有可能流量并没有减少，用与否视情况而定，个人选择。\n\n---\n####三角形\n> * 利用了相邻两个边框的接壤处分配原则\n> * 如果没有宽度和高度的话，其实应该是四个三角形接成的矩形 \n> * ![](/assets/images/2017/d_1.jpg)\n\n    .triangle-up { \n        width: 0; \n        height: 0; \n        border-left: 50px solid transparent; \n        border-right: 50px solid transparent;\n \tborder-bottom: 100px solid #669; \n    }\n\n---\n####圆形\n> * 利用了css3.0的圆角属性 border-radius 适当的调整大小会有不同的效果\n> * ![](/assets/images/2017/d_2.jpg)\n> * ![](/assets/images/2017/d_3.jpg)\n\n    .circle {\n        width: 100px; \n        height: 100px; \n        background: #669; \n        -moz-border-radius: 50px; \n        -webkit-border-radius: 50px; \n        border-radius: 50px; \n    }\n    .circle-circle { \n        width: 100px; \n        height: 100px; \n        border:20px solid #669;\n        background: #fff; \n        -moz-border-radius: 100px; \n        -webkit-border-radius: 100px; \n        border-radius: 100px; \n    }\n\n---\n####平行四边形\n> * 扭曲skew()函数能够让元素倾斜显示。它可以将一个对象以其中心位置围绕着X轴和Y轴按照一定的角度倾斜。\n\n    .parallelogram { \n        width: 150px; \n        height: 100px; \n        -webkit-transform: skew(-20deg); \n        -moz-transform: skew(-20deg); \n        -o-transform: skew(-20deg); \n        background: #669;\n        margin-left:20px; \n    }\n\n---","mobiledoc":null,"html":"<h4 id=\"\">优劣</h4>\n\n<p>利用css画图形，是个有利有弊的写法，好处是不用画图，且节省了一些流量，坏处是要写长串的css样式，而且有可能流量并没有减少，用与否视情况而定，个人选择。</p>\n\n<hr />\n\n<h4 id=\"\">三角形</h4>\n\n<blockquote>\n  <ul>\n  <li>利用了相邻两个边框的接壤处分配原则</li>\n  <li>如果没有宽度和高度的话，其实应该是四个三角形接成的矩形 </li>\n  <li><img src=\"/assets/images/2017/d_1.jpg\" alt=\"\" title=\"\" /></li>\n  </ul>\n</blockquote>\n\n<pre><code>.triangle-up { \n    width: 0; \n    height: 0; \n    border-left: 50px solid transparent; \n    border-right: 50px solid transparent;\n border-bottom: 100px solid #669; \n}\n</code></pre>\n\n<hr />\n\n<h4 id=\"\">圆形</h4>\n\n<blockquote>\n  <ul>\n  <li>利用了css3.0的圆角属性 border-radius 适当的调整大小会有不同的效果</li>\n  <li><img src=\"/assets/images/2017/d_2.jpg\" alt=\"\" title=\"\" /></li>\n  <li><img src=\"/assets/images/2017/d_3.jpg\" alt=\"\" title=\"\" /></li>\n  </ul>\n</blockquote>\n\n<pre><code>.circle {\n    width: 100px; \n    height: 100px; \n    background: #669; \n    -moz-border-radius: 50px; \n    -webkit-border-radius: 50px; \n    border-radius: 50px; \n}\n.circle-circle { \n    width: 100px; \n    height: 100px; \n    border:20px solid #669;\n    background: #fff; \n    -moz-border-radius: 100px; \n    -webkit-border-radius: 100px; \n    border-radius: 100px; \n}\n</code></pre>\n\n<hr />\n\n<h4 id=\"\">平行四边形</h4>\n\n<blockquote>\n  <ul>\n  <li>扭曲skew()函数能够让元素倾斜显示。它可以将一个对象以其中心位置围绕着X轴和Y轴按照一定的角度倾斜。</li>\n  </ul>\n</blockquote>\n\n<pre><code>.parallelogram { \n    width: 150px; \n    height: 100px; \n    -webkit-transform: skew(-20deg); \n    -moz-transform: skew(-20deg); \n    -o-transform: skew(-20deg); \n    background: #669;\n    margin-left:20px; \n}\n</code></pre>\n\n<hr />","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-18 03:10:48","created_by":1,"updated_at":"2017-05-18 07:16:19","updated_by":1,"published_at":"2017-05-18 07:16:19","published_by":1},{"id":7,"uuid":"146848f3-ea3c-4ede-93a1-24f2591ad95d","title":"CSS--Animation","slug":"css-draw","markdown":"####Transitions\n* 平滑的改变CSS的值\n > ![](/assets/images/2017/an_1.jpg)\n\n---\n####Transforms\n* 拉伸，压缩，旋转，偏移\n > ![](/assets/images/2017/an_2.jpg)\n\n---\n####Animation\n* 会在每个关键帧之间插入补间动画，所以动画效果是连贯性的\n > ![](/assets/images/2017/an_3.jpg)\n\n---","mobiledoc":null,"html":"<h4 id=\"transitions\">Transitions</h4>\n\n<p><ul>\n<li>平滑的改变CSS的值</p>\n\n<blockquote>\n  <img src=\"/assets/images/2017/an_1.jpg\" alt=\"\" title=\"\" /></li>\n  </ul>\n  <hr />\n</blockquote>\n\n<h4 id=\"transforms\">Transforms</h4>\n\n<p><ul>\n<li>拉伸，压缩，旋转，偏移</p>\n\n<blockquote>\n  <img src=\"/assets/images/2017/an_2.jpg\" alt=\"\" title=\"\" /></li>\n  </ul>\n  <hr />\n</blockquote>\n\n<h4 id=\"animation\">Animation</h4>\n\n<p><ul>\n<li>会在每个关键帧之间插入补间动画，所以动画效果是连贯性的</p>\n\n<blockquote>\n  <img src=\"/assets/images/2017/an_3.jpg\" alt=\"\" title=\"\" /></li>\n  </ul>\n  <hr />\n</blockquote>","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-18 03:12:25","created_by":1,"updated_at":"2017-05-18 07:02:50","updated_by":1,"published_at":"2017-05-18 07:00:22","published_by":1},{"id":8,"uuid":"ef788af4-a4b2-438c-8f1c-b165a66c88fd","title":"JS--AJAX","slug":"js-ajax","markdown":"####基本概念\nAJAX：异步 JavaScript 和 XML，创建快速动态网页的技术。\n通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。\n> ![The IE Box](/assets/images/2017/ja1.jpg)\n\n---\n####XMLHttpRequest 对象\n用于在后台与服务器交换数据\n> ![The IE Box](/assets/images/2017/ja3.jpg)\n\n---\n####三个常用的属性\n* Onreadystatechange：存有处理服务器响应的函数\n* readyState：存有服务器响应的状态信息，每当 readyState 改变时，onreadystatechange 函数就会被执行。\n* responseText：取回由服务器返回的数据。\n> ![The IE Box](/assets/images/2017/ja4.jpg)\n\n####方法\n* open：规定请求的类型、URL 以及是否异步处理请求\n* send：post方式 需要发送数据\n\n---\n####AJAX状态值\n运行AJAX所经历过的几种状态，无论访问是否成功都将响应的步骤，可以理解成为AJAX运行步骤。如：正在发送，正在响应等，由AJAX对象与服务器交互时所得；使用“ajax.readyState”获得。（由数字1~4单位数字组成）\n> ![The IE Box](/assets/images/2017/ja5.jpg)\n\n####AJAX状态码说明\nAJAX状态码是指，无论AJAX访问是否成功，由HTTP协议根据所提交的信息，服务器所返回的HTTP头信息代码，该信息使用“ajax.status”所获得；（由数字1XX,2XX三位数字组成，详细查看RFC）\n\n* `1**`：请求收到，继续处理\n* `2**`：操作成功收到，分析、接受\n* `3**`：完成此请求必须进一步处理\n* `4**`：请求包含一个错误语法或不能完成\n* `5**`：服务器执行一个完全有效请求失败\n\n---\n####优缺点\n* 使用异步方式与服务器通信，页面不需要重新加载，页面无刷新；按需取数据，减少服务器的负担；使得Web应用程序更为迅捷地响应用户交互；浏览器的内容和服务端代码进行分离。页面的内容全部由JAVAScript来控制，服务端负责逻辑的校验和从数据库中拿数据。\n* 将服务端的方法暴露出来，黑客可利用这一点进行攻击；大量JS代码，容易出错；Ajax的无刷新重载，由于页面的变化没有刷新重载那么明显，所以容易给用户带来困扰——用户不太清楚现在的数据是新的还是已经更新过的；可能破坏浏览器后退按钮的正常行为；一些手持设备（如手机、PAD等）自带的浏览器现在还不能很好的支持Ajax。\n####跨域请求\n同一个ip、同一个网络协议、同一个端口，三者都满足就是同一个域，否则就是跨域问题了。说白点就是post、get的url不是你当前的网站，域名不同。\n\n* 同源策略\n* 跨域资源共享\n* 解决方案\n * CORS 跨源资源共享：`Cross-Origin Resource Sharing`（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。用 CORS 可以让网页设计师用一般的 XMLHttpRequest，这种方式的错误处理比 JSONP 要来的好。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS。\n * JSONP：JSONP 是 JSON 的一种使用模式，可以解决主流浏览器的跨域数据访问问题。其原理是根据 `XmlHttpRequest` 对象受到同源策略的影响，而 `<script>` 标签元素却不受同源策略影响，可以加载跨域服务器上的脚本，网页可以从其他来源动态产生 JSON 资料。用 JSONP 获取的不是 JSON 数据，而是可以直接运行的 JavaScript 语句。\n * 代理\n\n\n","mobiledoc":null,"html":"<h4 id=\"\">基本概念</h4>\n\n<p>AJAX：异步 JavaScript 和 XML，创建快速动态网页的技术。 <br />\n通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/ja1.jpg\" alt=\"The IE Box\" title=\"\" /></p>\n</blockquote>\n\n<hr />\n\n<h4 id=\"xmlhttprequest\">XMLHttpRequest 对象</h4>\n\n<p>用于在后台与服务器交换数据</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/ja3.jpg\" alt=\"The IE Box\" title=\"\" /></p>\n</blockquote>\n\n<hr />\n\n<h4 id=\"\">三个常用的属性</h4>\n\n<ul>\n<li>Onreadystatechange：存有处理服务器响应的函数</li>\n<li>readyState：存有服务器响应的状态信息，每当 readyState 改变时，onreadystatechange 函数就会被执行。</li>\n<li>responseText：取回由服务器返回的数据。\n\n\n<blockquote>\n  <img src=\"/assets/images/2017/ja4.jpg\" alt=\"The IE Box\" title=\"\" /></li>\n  </ul>\n  <h4 id=\"\">方法</h4>\n</blockquote>\n\n<ul>\n<li>open：规定请求的类型、URL 以及是否异步处理请求</li>\n<li>send：post方式 需要发送数据</li>\n</ul>\n\n<hr />\n\n<h4 id=\"ajax\">AJAX状态值</h4>\n\n<p>运行AJAX所经历过的几种状态，无论访问是否成功都将响应的步骤，可以理解成为AJAX运行步骤。如：正在发送，正在响应等，由AJAX对象与服务器交互时所得；使用“ajax.readyState”获得。（由数字1~4单位数字组成）</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/ja5.jpg\" alt=\"The IE Box\" title=\"\" /></p>\n</blockquote>\n\n<h4 id=\"ajax\">AJAX状态码说明</h4>\n\n<p>AJAX状态码是指，无论AJAX访问是否成功，由HTTP协议根据所提交的信息，服务器所返回的HTTP头信息代码，该信息使用“ajax.status”所获得；（由数字1XX,2XX三位数字组成，详细查看RFC）</p>\n\n<ul>\n<li><code>1**</code>：请求收到，继续处理</li>\n<li><code>2**</code>：操作成功收到，分析、接受</li>\n<li><code>3**</code>：完成此请求必须进一步处理</li>\n<li><code>4**</code>：请求包含一个错误语法或不能完成</li>\n<li><code>5**</code>：服务器执行一个完全有效请求失败</li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">优缺点</h4>\n\n<ul>\n<li>使用异步方式与服务器通信，页面不需要重新加载，页面无刷新；按需取数据，减少服务器的负担；使得Web应用程序更为迅捷地响应用户交互；浏览器的内容和服务端代码进行分离。页面的内容全部由JAVAScript来控制，服务端负责逻辑的校验和从数据库中拿数据。</li>\n<li>将服务端的方法暴露出来，黑客可利用这一点进行攻击；大量JS代码，容易出错；Ajax的无刷新重载，由于页面的变化没有刷新重载那么明显，所以容易给用户带来困扰——用户不太清楚现在的数据是新的还是已经更新过的；可能破坏浏览器后退按钮的正常行为；一些手持设备（如手机、PAD等）自带的浏览器现在还不能很好的支持Ajax。</li>\n</ul>\n\n<h4 id=\"\">跨域请求</h4>\n\n<p>同一个ip、同一个网络协议、同一个端口，三者都满足就是同一个域，否则就是跨域问题了。说白点就是post、get的url不是你当前的网站，域名不同。</p>\n\n<ul>\n<li>同源策略</li>\n<li>跨域资源共享</li>\n<li>解决方案\n<ul><li>CORS 跨源资源共享：<code>Cross-Origin Resource Sharing</code>（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。用 CORS 可以让网页设计师用一般的 XMLHttpRequest，这种方式的错误处理比 JSONP 要来的好。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS。</li>\n<li>JSONP：JSONP 是 JSON 的一种使用模式，可以解决主流浏览器的跨域数据访问问题。其原理是根据 <code>XmlHttpRequest</code> 对象受到同源策略的影响，而 <code>&lt;script&gt;</code> 标签元素却不受同源策略影响，可以加载跨域服务器上的脚本，网页可以从其他来源动态产生 JSON 资料。用 JSONP 获取的不是 JSON 数据，而是可以直接运行的 JavaScript 语句。</li>\n<li>代理</li></ul></li>\n</ul>","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-18 07:18:18","created_by":1,"updated_at":"2017-05-25 02:58:12","updated_by":1,"published_at":"2017-05-25 02:58:12","published_by":1},{"id":9,"uuid":"f00b557c-db3c-40a5-ae2f-a564b3379a68","title":"JS--BOM","slug":"js_bom","markdown":"####基本概念\n* BOM的意思是浏览器对象模型（Browser Object Model），就是JavaScript中的window对象。\n* window（BOM）内包含document、history、location、navigator、screen等对象，其中document就是DOM！\n>![](/assets/images/2017/b1.jpg)\n\n####window对象\n* 浏览器在JavaScript中的一个实例。对window对象属性的操作可以获取或操作网页标签的状态、大小、位置等。所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。全局变量是 window 对象的属性。全局函数是 window 对象的方法。\n* Screen 对象包含有关客户端显示屏幕的信息。screen对象可以理解成显示器在JavaScript中的一个实例。\n* Navigator 对象包含有关浏览器的信息。navigator对象可以理解成当前浏览器（不是网页标签）在JavaScript中的一个实例。\n* Location 对象包含有关当前 URL 的信息。location对象可以理解成当前网页网址在JavaScript中的一个实例。\n* History 对象包含用户（在浏览器窗口中）访问过的 URL。history对象可以理解成浏览器历史记录在JavaScript中的一个实例。\n* 每个载入浏览器的 HTML 文档都会成为 Document 对象。Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。document对象可以理解为HTML文件在JavaScript中的一个实例。\n\n---\n","mobiledoc":null,"html":"<h4 id=\"\">基本概念</h4>\n\n<ul>\n<li>BOM的意思是浏览器对象模型（Browser Object Model），就是JavaScript中的window对象。</li>\n<li>window（BOM）内包含document、history、location、navigator、screen等对象，其中document就是DOM！\n\n\n<blockquote>\n  <img src=\"/assets/images/2017/b1.jpg\" alt=\"\" title=\"\" /></li>\n  </ul>\n  <h4 id=\"window\">window对象</h4>\n</blockquote>\n\n<ul>\n<li>浏览器在JavaScript中的一个实例。对window对象属性的操作可以获取或操作网页标签的状态、大小、位置等。所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。全局变量是 window 对象的属性。全局函数是 window 对象的方法。</li>\n<li>Screen 对象包含有关客户端显示屏幕的信息。screen对象可以理解成显示器在JavaScript中的一个实例。</li>\n<li>Navigator 对象包含有关浏览器的信息。navigator对象可以理解成当前浏览器（不是网页标签）在JavaScript中的一个实例。</li>\n<li>Location 对象包含有关当前 URL 的信息。location对象可以理解成当前网页网址在JavaScript中的一个实例。</li>\n<li>History 对象包含用户（在浏览器窗口中）访问过的 URL。history对象可以理解成浏览器历史记录在JavaScript中的一个实例。</li>\n<li>每个载入浏览器的 HTML 文档都会成为 Document 对象。Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。document对象可以理解为HTML文件在JavaScript中的一个实例。</li>\n</ul>\n\n<hr />","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-18 07:18:31","created_by":1,"updated_at":"2017-05-25 06:45:51","updated_by":1,"published_at":"2017-05-25 06:45:51","published_by":1},{"id":10,"uuid":"224c291c-d0d1-4c87-8588-ab2026a8375d","title":"JS--DOM&Event","slug":"js_dom-event","markdown":"####JS操作DOM树\n* 创建新元素：`document.createElement(elementTagName)`\n* 添加：`appendChild(newElement)`和`insertBefore(newElement,beforeWhichElement)`\n* 删除：`removeChild(element)` 先找到父元素，然后删除子元素\n* 移动\n>![move](/assets/images/2017/d1.jpg)\n>![move](/assets/images/2017/d2.jpg)\n\n* 复制：`cloneNode(cloneChildNodes)`\n* 查找\n> ![move](/assets/images/2017/d3.jpg)\n\n---\n####事件流\n* 捕获型：事件的传播是从最不特定的事件目标到最特定的事件目标。即从DOM树的根到叶子。事件捕获的思想就是不太具体的节点应该更早接收到事件，而最具体的节点最后接收到事件。\n* 冒泡型：事件的传播是从最特定的事件目标到最不特定的事件目标。即从DOM树的叶子到根。\n####DOM事件流\n* 三个阶段：事件捕获阶段+处于目标阶段+事件冒泡阶段\n* 事件绑定的写法\n * `document.getElementById(\"test\").onclick = function(e){}`，后续添加的事件会覆盖前面的，无法绑定多个事件；\n * `addEventListener`和`removeEventListener`，最后一个参数是布尔型，`true`代表捕获事件，`false`代表冒泡事件。\n>![](/assets/images/2017/d4.jpg)\n\n---\n \n","mobiledoc":null,"html":"<h4 id=\"jsdom\">JS操作DOM树</h4>\n\n<ul>\n<li>创建新元素：<code>document.createElement(elementTagName)</code></li>\n<li>添加：<code>appendChild(newElement)</code>和<code>insertBefore(newElement,beforeWhichElement)</code></li>\n<li>删除：<code>removeChild(element)</code> 先找到父元素，然后删除子元素</li>\n<li><p>移动</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/d1.jpg\" alt=\"move\" title=\"\" />\n  <img src=\"/assets/images/2017/d2.jpg\" alt=\"move\" title=\"\" /></p>\n</blockquote></li>\n<li><p>复制：<code>cloneNode(cloneChildNodes)</code></p></li>\n<li>查找\n\n\n<blockquote>\n  <img src=\"/assets/images/2017/d3.jpg\" alt=\"move\" title=\"\" /></li>\n  </ul>\n  <hr />\n</blockquote>\n\n<h4 id=\"\">事件流</h4>\n\n<ul>\n<li>捕获型：事件的传播是从最不特定的事件目标到最特定的事件目标。即从DOM树的根到叶子。事件捕获的思想就是不太具体的节点应该更早接收到事件，而最具体的节点最后接收到事件。</li>\n<li>冒泡型：事件的传播是从最特定的事件目标到最不特定的事件目标。即从DOM树的叶子到根。</li>\n</ul>\n\n<h4 id=\"dom\">DOM事件流</h4>\n\n<p><ul>\n<li>三个阶段：事件捕获阶段+处于目标阶段+事件冒泡阶段</li>\n<li>事件绑定的写法\n<ul><li><code>document.getElementById(\"test\").onclick = function(e){}</code>，后续添加的事件会覆盖前面的，无法绑定多个事件；</li>\n<li><code>addEventListener</code>和<code>removeEventListener</code>，最后一个参数是布尔型，<code>true</code>代表捕获事件，<code>false</code>代表冒泡事件。</p>\n\n<blockquote>\n  <img src=\"/assets/images/2017/d4.jpg\" alt=\"\" title=\"\" /></li></ul></li>\n  </ul>\n  <hr />\n</blockquote>","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-18 07:18:48","created_by":1,"updated_at":"2017-05-25 06:42:40","updated_by":1,"published_at":"2017-05-25 06:42:31","published_by":1},{"id":11,"uuid":"45daac11-a19d-4773-b916-128fbb98d4f1","title":"JS--JSON","slug":"js-json","markdown":"####为什么使用JSON而不是XML\n* `JavaScript Object Notation`，意思是JavaScript对象表示法，它是一种基于文本，独立于语言的轻量级数据交换格式。\n* `XML`也是一种数据交换格式，虽然可以作为跨平台的数据交换格式，但是在JS中处理XML非常不方便，同时XML标记比数据多，增加了交换产生的流量，而JSON没有附加的任何标记，在JS中可作为对象处理，所以我们更倾向于选择JSON来交换数据。\n####JSON：JavaScript Object Notation，数据交换格式\n* Json字符串：符合json格式要求的js字符串；\n`var jsonStr = '{\"name\": \"hujing\", \"age\": 29}'`\n* Json对象：指符合json格式要求的js对象，可以包含简单值、对象以及数组；\n`var jsonObj = {\"name\": \"hujing\",\"age\": 29}`\n\n---\n####JSON字符串转换成JSON对象（解析）\n* `eval()`函数：解析、解释并返回对象和数组，但是效率较低且存在风险，可能会用来执行一些恶意代码；\n* `JSON.parse(jsonStr)`；\n####JSON对象转换成JSON字符串（序列化）\n* `jsonObj.toString()`;\n* `JSON.stringify(jsonObj)`;\n####序列化顺序\n* 如果存在`toJSON()`方法且能通过它取得有效的值，则调用该方法。否则，返回对象本身；\n* 如果提供了第二个参数，应用这个函数过滤器。传入过滤器的值是1返回的结果；\n* 对2返回的每个值进行相应的序列化；\n* 如果提供了第三个参数，则执行相应的格式化。\n\n---\n\n","mobiledoc":null,"html":"<h4 id=\"jsonxml\">为什么使用JSON而不是XML</h4>\n\n<ul>\n<li><code>JavaScript Object Notation</code>，意思是JavaScript对象表示法，它是一种基于文本，独立于语言的轻量级数据交换格式。</li>\n<li><code>XML</code>也是一种数据交换格式，虽然可以作为跨平台的数据交换格式，但是在JS中处理XML非常不方便，同时XML标记比数据多，增加了交换产生的流量，而JSON没有附加的任何标记，在JS中可作为对象处理，所以我们更倾向于选择JSON来交换数据。</li>\n</ul>\n\n<h4 id=\"jsonjavascriptobjectnotation\">JSON：JavaScript Object Notation，数据交换格式</h4>\n\n<ul>\n<li>Json字符串：符合json格式要求的js字符串；\n<code>var jsonStr = '{\"name\": \"hujing\", \"age\": 29}'</code></li>\n<li>Json对象：指符合json格式要求的js对象，可以包含简单值、对象以及数组；\n<code>var jsonObj = {\"name\": \"hujing\",\"age\": 29}</code></li>\n</ul>\n\n<hr />\n\n<h4 id=\"jsonjson\">JSON字符串转换成JSON对象（解析）</h4>\n\n<ul>\n<li><code>eval()</code>函数：解析、解释并返回对象和数组，但是效率较低且存在风险，可能会用来执行一些恶意代码；</li>\n<li><code>JSON.parse(jsonStr)</code>；</li>\n</ul>\n\n<h4 id=\"jsonjson\">JSON对象转换成JSON字符串（序列化）</h4>\n\n<ul>\n<li><code>jsonObj.toString()</code>;</li>\n<li><code>JSON.stringify(jsonObj)</code>;</li>\n</ul>\n\n<h4 id=\"\">序列化顺序</h4>\n\n<ul>\n<li>如果存在<code>toJSON()</code>方法且能通过它取得有效的值，则调用该方法。否则，返回对象本身；</li>\n<li>如果提供了第二个参数，应用这个函数过滤器。传入过滤器的值是1返回的结果；</li>\n<li>对2返回的每个值进行相应的序列化；</li>\n<li>如果提供了第三个参数，则执行相应的格式化。</li>\n</ul>\n\n<hr />","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-18 07:19:15","created_by":1,"updated_at":"2017-05-25 03:02:52","updated_by":1,"published_at":"2017-05-25 03:02:21","published_by":1},{"id":12,"uuid":"6a54e87e-049c-4ee1-8e79-525769b1baa2","title":"JS--面向对象","slug":"js-mian-xiang-dui-xiang","markdown":"####创建对象\n* 原始模式：这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。\n> ![](/assets/images/2017/j21.jpg)\n> ![](/assets/images/2017/j22.jpg)\n\n* 工厂模式：解决代码重复的问题，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。\n> ![](/assets/images/2017/j23.jpg)\n> ![](/assets/images/2017/j24.jpg)\n\n* 构造函数模式：所谓\"构造函数\"，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。构造函数方法很好用，但是存在一个浪费内存的问题，相同的属性和方法每次都要生成。\n> ![](/assets/images/2017/j25.jpg)\n> ![](/assets/images/2017/j26.jpg)\n> ![](/assets/images/2017/j27.jpg)\n> ![](/assets/images/2017/j28.jpg)\n\n* Prototype（混合）模式：Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承，我们可以把那些不变的属性和方法，直接定义在prototype对象上。\n> ![](/assets/images/2017/j29.jpg)\n> ![](/assets/images/2017/j210.jpg)\n\n---\n####继承\n* 原型对象：最重要的作用就是把常量和方法独立到自身里，供给其它实例使用。\n> ![](/assets/images/2017/j211.jpg)\n\n* 原型链：JavaScritp引擎在访问对象的属性时，如果在对象本身中没有找到，则会去原型链中查找，如果找到，直接返回值，如果整个链都遍历且没有找到属性，则返回undefined。原型链一般实现为一个链表，这样就可以按照一定的顺序来查找。\n* 继承实现\n * Js原型实现继承：引用类型的原型属性（数组、对象等）会被所有实例共享；在创建子类型的实例时，不能向父类的构造函数传递参数。\n >![](/assets/images/2017/j212.jpg)\n \n * 构造函数实现继承\n >![](/assets/images/2017/j214.jpg)\n\n * call , apply实现组合继承\n >![](/assets/images/2017/j217.jpg)\n\n * 寄生式继承\n >![](/assets/images/2017/j221.jpg)\n\n * 寄生组合继承\n >![](/assets/images/2017/j223.jpg)\n\n---\n####call和apply详解\n* call和apply都可以实现继承，唯一的一点参数不同，func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3])。\n* call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。\n>![](/assets/images/2017/j224.jpg)\n>![](/assets/images/2017/j225.jpg)\n>![](/assets/images/2017/j226.jpg)\n\n","mobiledoc":null,"html":"<h4 id=\"\">创建对象</h4>\n\n<ul>\n<li><p>原始模式：这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/j21.jpg\" alt=\"\" title=\"\" />\n  <img src=\"/assets/images/2017/j22.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote></li>\n<li><p>工厂模式：解决代码重复的问题，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/j23.jpg\" alt=\"\" title=\"\" />\n  <img src=\"/assets/images/2017/j24.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote></li>\n<li><p>构造函数模式：所谓\"构造函数\"，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。构造函数方法很好用，但是存在一个浪费内存的问题，相同的属性和方法每次都要生成。</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/j25.jpg\" alt=\"\" title=\"\" />\n  <img src=\"/assets/images/2017/j26.jpg\" alt=\"\" title=\"\" />\n  <img src=\"/assets/images/2017/j27.jpg\" alt=\"\" title=\"\" />\n  <img src=\"/assets/images/2017/j28.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote></li>\n<li><p>Prototype（混合）模式：Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承，我们可以把那些不变的属性和方法，直接定义在prototype对象上。</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/j29.jpg\" alt=\"\" title=\"\" />\n  <img src=\"/assets/images/2017/j210.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote></li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">继承</h4>\n\n<ul>\n<li><p>原型对象：最重要的作用就是把常量和方法独立到自身里，供给其它实例使用。</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/j211.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote></li>\n<li><p>原型链：JavaScritp引擎在访问对象的属性时，如果在对象本身中没有找到，则会去原型链中查找，如果找到，直接返回值，如果整个链都遍历且没有找到属性，则返回undefined。原型链一般实现为一个链表，这样就可以按照一定的顺序来查找。</p></li>\n<li><p>继承实现</p>\n\n<ul><li><p>Js原型实现继承：引用类型的原型属性（数组、对象等）会被所有实例共享；在创建子类型的实例时，不能向父类的构造函数传递参数。</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/j212.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote></li>\n<li><p>构造函数实现继承</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/j214.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote></li>\n<li><p>call , apply实现组合继承</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/j217.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote></li>\n<li><p>寄生式继承</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/j221.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote></li>\n<li><p>寄生组合继承</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/j223.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote></li></ul></li>\n</ul>\n\n<hr />\n\n<h4 id=\"callapply\">call和apply详解</h4>\n\n<p><ul>\n<li>call和apply都可以实现继承，唯一的一点参数不同，func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3])。</li>\n<li>call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/j224.jpg\" alt=\"\" title=\"\" />\n  <img src=\"/assets/images/2017/j225.jpg\" alt=\"\" title=\"\" />\n  <img src=\"/assets/images/2017/j226.jpg\" alt=\"\" title=\"\" /></li>\n  </ul></p>\n</blockquote>","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-18 07:19:31","created_by":1,"updated_at":"2017-05-24 02:23:03","updated_by":1,"published_at":"2017-05-24 02:23:03","published_by":1},{"id":13,"uuid":"9027625e-7a14-4ccf-870f-6eb1aaf1bc5a","title":"JS--数据类型","slug":"js-shu-ju-lei-xing","markdown":"####基本数据类型\n* Undefined类型只有一个值undefined，当变量被声明但未被赋值时为undefined，typeof未初始化或者未声明的变量都返回undefined；\n* Null类型只有一个值null，表示一个空指针，typeof返回object；\n* `Number.MIN_VALUE`、`Number.MAX_VALUE`、`Infinity`、`NaN`(与任何值都不相等)；`Number()`、`parseInt()`、`parseFloat()`；\n* String的值是不可变的、`toString`、`+\" \"`转化成字符串。\n####Undefined与null的区别\n* JavaScript的最初版本是这样区分的：null是一个表示\"无\"的对象，转为数值时为0；undefined是一个表示\"无\"的原始值，转为数值时为NaN。\n* null表示\"没有对象\"，该处不应该有值，用来表示函数企图返回一个不存在的对象。\n* undefined表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。\n####类型判断\n* typeof：返回的类型都是字符串形式\n* instanceof：判断已知对象类型的方法\n* constructor：根据对象的constructor判断，在类继承时会出错\n* prototype：`Object.prototype.toString.call(a) === '[object String]'`\n* jquery.type()：`jQuery.type( null ) === 'null'`。利用Object.toString.call()方法\n####操作符\n* `==`、`!=`：先转换再比较，null和undefined相等；\n* `===`、`!==`：仅比较而不转换，类型不同则不相等。\n####复合类型\n* 函数：function；\n* 数组：Array；`push()`、`pop()`、`unshift()`、`shift()`、`sort(compare)`，`value1<value2` 返回-1表示正序,返回1表示倒序、`indexOf()`、`lastIndexOf()`、`splice()`；\n* 类：Object，`instanceof`。\n\n---\n####内存管理\n* 原始值和引用值存储在内存中的位置分别为栈和堆。\n* 原始值是存储在栈中的简单数据段，他们的值直接存储在变量访问的位置。\n* 引用值是存储在堆中的对象。存储在栈中的值是一个指针，指向存储在堆中的实际对象。\n* 栈的优势就是存取速度比堆要快，仅次于直接位于CPU中的寄存器，但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，垃圾收集器会自动地收走这些不再使用的数据，但是缺点是由于在运行时动态分配内存，所以存取速度较慢。\n> ![The IE Box](/assets/images/2017/j1.jpg)\n\n---\n####垃圾回收机制\n* 标记清除：标记清除简单的来说就是给各个变量名打上 YES or NO的标签以供JS引擎进行处理（当然打什么标签自己理解即可）。在和执行上下文类似的的环境中当变量名称进入环境的时候，那么变量会被打上 YES。一般来说是绝对不会释放被打上 YES 标签的变量内存的，一旦变量在出了该环境时，变会被打上 NO 标签（和作用域貌似有点像），JS引擎会在一定时间间隔或者设置的时间来进行扫描，对NO标签的进行剔除以释放其内存。\n* 引用计数：一般来说，引用计数的含义是跟踪记录每个值被引用的次数。当声明一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数便是1，如果同一个值又被赋给另一个变量，则该值的引用次数加1，相反，如果包含对这个值引用的变量又取得了另一个值，则这个值的引用次数减1。当这个值的引用次数为0时，说明没有办法访问到它了，因而可以将其占用的内存空间回收。\n\n---\n####作用域\n> * 声明提升：JavaScript引擎在执行的时候，会把所有变量的声明都提升到当前作用域的最前面；\n> * 函数作用域，无块级作用域；\n> * 作用域链\n>  * 创建函数![The IE Box](/assets/images/2017/j2.jpg)\n>  * 调用函数![The IE Box](/assets/images/2017/j3.jpg)\n\n    .function add(num1,num2) {\n        var sum = num1 + num2;\n        return sum;\n    }\n    var total = add(5,10);\n\n> * With改变作用域链![The IE Box](/assets/images/2017/j4.jpg)\n\n    .function initUI(){\n        with(document){\n            var bd=body,\n            links=getElementsByTagName(\"a\"),\n            i=0,\n            len=links.length;\n            while(i < len){\n                update(links[i++]);\n            }\n            getElementById(\"btnInit\").onclick=function(){\n                doSomething();\n            };\n    }\n\n","mobiledoc":null,"html":"<h4 id=\"\">基本数据类型</h4>\n\n<ul>\n<li>Undefined类型只有一个值undefined，当变量被声明但未被赋值时为undefined，typeof未初始化或者未声明的变量都返回undefined；</li>\n<li>Null类型只有一个值null，表示一个空指针，typeof返回object；</li>\n<li><code>Number.MIN_VALUE</code>、<code>Number.MAX_VALUE</code>、<code>Infinity</code>、<code>NaN</code>(与任何值都不相等)；<code>Number()</code>、<code>parseInt()</code>、<code>parseFloat()</code>；</li>\n<li>String的值是不可变的、<code>toString</code>、<code>+\" \"</code>转化成字符串。</li>\n</ul>\n\n<h4 id=\"undefinednull\">Undefined与null的区别</h4>\n\n<ul>\n<li>JavaScript的最初版本是这样区分的：null是一个表示\"无\"的对象，转为数值时为0；undefined是一个表示\"无\"的原始值，转为数值时为NaN。</li>\n<li>null表示\"没有对象\"，该处不应该有值，用来表示函数企图返回一个不存在的对象。</li>\n<li>undefined表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。</li>\n</ul>\n\n<h4 id=\"\">类型判断</h4>\n\n<ul>\n<li>typeof：返回的类型都是字符串形式</li>\n<li>instanceof：判断已知对象类型的方法</li>\n<li>constructor：根据对象的constructor判断，在类继承时会出错</li>\n<li>prototype：<code>Object.prototype.toString.call(a) === '[object String]'</code></li>\n<li>jquery.type()：<code>jQuery.type( null ) === 'null'</code>。利用Object.toString.call()方法</li>\n</ul>\n\n<h4 id=\"\">操作符</h4>\n\n<ul>\n<li><code>==</code>、<code>!=</code>：先转换再比较，null和undefined相等；</li>\n<li><code>===</code>、<code>!==</code>：仅比较而不转换，类型不同则不相等。</li>\n</ul>\n\n<h4 id=\"\">复合类型</h4>\n\n<ul>\n<li>函数：function；</li>\n<li>数组：Array；<code>push()</code>、<code>pop()</code>、<code>unshift()</code>、<code>shift()</code>、<code>sort(compare)</code>，<code>value1&lt;value2</code> 返回-1表示正序,返回1表示倒序、<code>indexOf()</code>、<code>lastIndexOf()</code>、<code>splice()</code>；</li>\n<li>类：Object，<code>instanceof</code>。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">内存管理</h4>\n\n<ul>\n<li>原始值和引用值存储在内存中的位置分别为栈和堆。</li>\n<li>原始值是存储在栈中的简单数据段，他们的值直接存储在变量访问的位置。</li>\n<li>引用值是存储在堆中的对象。存储在栈中的值是一个指针，指向存储在堆中的实际对象。</li>\n<li>栈的优势就是存取速度比堆要快，仅次于直接位于CPU中的寄存器，但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，垃圾收集器会自动地收走这些不再使用的数据，但是缺点是由于在运行时动态分配内存，所以存取速度较慢。\n\n\n<blockquote>\n  <img src=\"/assets/images/2017/j1.jpg\" alt=\"The IE Box\" title=\"\" /></li>\n  </ul>\n  <hr />\n</blockquote>\n\n<h4 id=\"\">垃圾回收机制</h4>\n\n<ul>\n<li>标记清除：标记清除简单的来说就是给各个变量名打上 YES or NO的标签以供JS引擎进行处理（当然打什么标签自己理解即可）。在和执行上下文类似的的环境中当变量名称进入环境的时候，那么变量会被打上 YES。一般来说是绝对不会释放被打上 YES 标签的变量内存的，一旦变量在出了该环境时，变会被打上 NO 标签（和作用域貌似有点像），JS引擎会在一定时间间隔或者设置的时间来进行扫描，对NO标签的进行剔除以释放其内存。</li>\n<li>引用计数：一般来说，引用计数的含义是跟踪记录每个值被引用的次数。当声明一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数便是1，如果同一个值又被赋给另一个变量，则该值的引用次数加1，相反，如果包含对这个值引用的变量又取得了另一个值，则这个值的引用次数减1。当这个值的引用次数为0时，说明没有办法访问到它了，因而可以将其占用的内存空间回收。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">作用域</h4>\n\n<blockquote>\n  <ul>\n  <li>声明提升：JavaScript引擎在执行的时候，会把所有变量的声明都提升到当前作用域的最前面；</li>\n  <li>函数作用域，无块级作用域；</li>\n  <li>作用域链\n  <ul><li>创建函数<img src=\"/assets/images/2017/j2.jpg\" alt=\"The IE Box\" title=\"\" /></li>\n  <li>调用函数<img src=\"/assets/images/2017/j3.jpg\" alt=\"The IE Box\" title=\"\" /></li></ul></li>\n  </ul>\n</blockquote>\n\n<pre><code>.function add(num1,num2) {\n    var sum = num1 + num2;\n    return sum;\n}\nvar total = add(5,10);\n</code></pre>\n\n<blockquote>\n  <ul>\n  <li>With改变作用域链<img src=\"/assets/images/2017/j4.jpg\" alt=\"The IE Box\" title=\"\" /></li>\n  </ul>\n</blockquote>\n\n<pre><code>.function initUI(){\n    with(document){\n        var bd=body,\n        links=getElementsByTagName(\"a\"),\n        i=0,\n        len=links.length;\n        while(i &lt; len){\n            update(links[i++]);\n        }\n        getElementById(\"btnInit\").onclick=function(){\n            doSomething();\n        };\n}\n</code></pre>","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-18 07:19:42","created_by":1,"updated_at":"2017-05-24 01:40:43","updated_by":1,"published_at":"2017-05-24 01:40:43","published_by":1},{"id":14,"uuid":"6b119d55-f43a-4700-baae-6a3c6bfce937","title":"HTTP--基础","slug":"http","markdown":"####URL与URI的区别。\n* uniform resource location 统一资源定位符\n* uniform resource identifier 统一资源标识符\n####请求报文\n>![2](/assets/images/2017/HTTP1.jpg)\n####响应报文\n>![2](/assets/images/2017/HTTP2.jpg)\n\n---\n####GET与POST的区别。\n* 使用目标：POST与GET都用于获取信息，但是GET方式仅仅是查询，并不对服务器上的内容产生任何作用结果；每次GET的内容都是相同的。POST则常用于发送一定的内容进行某些修改操作。\n* 大小限制：由于不同的浏览器对URL的长度大小有一定的字符限制，因此由于GET方式放在URL的首部中，自然也跟着首先，但是具体的大小要依浏览器而定。POST方式则是把内容放在报文内容中，因此只要报文的内容没有限制，它的大小就没有限制。\n* 安全性：上面也说了GET是直接添加到URL后面的，直接就可以在URL中看到内容。而POST是放在报文内部的，用户无法直接看到。\n* GET用于获取某个内容，POST用于提交某种数据请求。按照使用场景来说，一般用户注册的内容属于私密的，这应该使用POST方式；而针对某一内容的查询，为了快速的响应，可以使用GET方式。\n\n---\n####Cookie\nCookie是一种由服务器端确定，并保存在客户端浏览器中的内容。这样，就不需要每次都添加用户的相关信息，请求会自动添加cookie中对应的内容。\n![](/assets/images/2017/HTTP3.jpg)![](/assets/images/2017/HTTP4.jpg)\n  \n####持久化\n如果每次想要发送http报文都需要经过这个过程，那么时间大部分都会消耗在建立和断开连接的过程中。因此http中使用了connection属性，用于指定连接的方式。　当设置成keep-alive，如上面所示的www.baidu.com的http头部信息所示，就会建立一条持久化的连接。不需要每次都建立连接，再中断。\n![](/assets/images/2017/HTTP5.jpg)![](/assets/images/2017/HTTP6.jpg)\n\n####管道化\n如果一个http请求，请求了大量的图片等大文件，那么其他的http请求怎么办呢？http可以一次发送多个http请求，然后等待响应连接。不需要排队等候，这样就加快了http的响应时间。\n\n####内容编码\n由于某些报文的内容过大，因此在传输时，为了减少传输的时间，会采取一些压缩的措施。如上面的报文信息中，Accept-Encoding就定义了内容编码的格式：gzip\n\n---\n####其他传输方式\n* PUT：传输文件，在请求报文的主体中包含文件内容，然后保存到请求URL指定的位置，有安全问题；\n* HEAD：获得报文首部，不返回报文主体部分，用于确认URI的有效性及资源更新的日期时间等；\n* DELETE：删除文件，DELETE是与PUT相反的方法，是按请求URI删除指定的资源\n* OPYIONS：询问支持的方法，用来查询针对请求URI指定的资源支持的方法\n* TRACE：追踪路径，让web服务器端将之前的请求通信还回给客户端的方法，发送请求时，在Max-Frowards首部字段中填入数值，每经过一个服务器端就-1，当数值为0时，停止传输，最后收到服务器返回状态码200 OK的响应\n* CONNECT：要求采用隧道协议连接代理，该方法要求在于代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经过网络传输。\n","mobiledoc":null,"html":"<h4 id=\"urluri\">URL与URI的区别。</h4>\n\n<ul>\n<li>uniform resource location 统一资源定位符</li>\n<li>uniform resource identifier 统一资源标识符</li>\n</ul>\n\n<h4 id=\"\">请求报文</h4>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/HTTP1.jpg\" alt=\"2\" title=\"\" /></p>\n</blockquote>\n\n<h4 id=\"\">响应报文</h4>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/HTTP2.jpg\" alt=\"2\" title=\"\" /></p>\n</blockquote>\n\n<hr />\n\n<h4 id=\"getpost\">GET与POST的区别。</h4>\n\n<ul>\n<li>使用目标：POST与GET都用于获取信息，但是GET方式仅仅是查询，并不对服务器上的内容产生任何作用结果；每次GET的内容都是相同的。POST则常用于发送一定的内容进行某些修改操作。</li>\n<li>大小限制：由于不同的浏览器对URL的长度大小有一定的字符限制，因此由于GET方式放在URL的首部中，自然也跟着首先，但是具体的大小要依浏览器而定。POST方式则是把内容放在报文内容中，因此只要报文的内容没有限制，它的大小就没有限制。</li>\n<li>安全性：上面也说了GET是直接添加到URL后面的，直接就可以在URL中看到内容。而POST是放在报文内部的，用户无法直接看到。</li>\n<li>GET用于获取某个内容，POST用于提交某种数据请求。按照使用场景来说，一般用户注册的内容属于私密的，这应该使用POST方式；而针对某一内容的查询，为了快速的响应，可以使用GET方式。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"cookie\">Cookie</h4>\n\n<p>Cookie是一种由服务器端确定，并保存在客户端浏览器中的内容。这样，就不需要每次都添加用户的相关信息，请求会自动添加cookie中对应的内容。 <br />\n<img src=\"/assets/images/2017/HTTP3.jpg\" alt=\"\" title=\"\" /><img src=\"/assets/images/2017/HTTP4.jpg\" alt=\"\" title=\"\" /></p>\n\n<h4 id=\"\">持久化</h4>\n\n<p>如果每次想要发送http报文都需要经过这个过程，那么时间大部分都会消耗在建立和断开连接的过程中。因此http中使用了connection属性，用于指定连接的方式。　当设置成keep-alive，如上面所示的www.baidu.com的http头部信息所示，就会建立一条持久化的连接。不需要每次都建立连接，再中断。\n<img src=\"/assets/images/2017/HTTP5.jpg\" alt=\"\" title=\"\" /><img src=\"/assets/images/2017/HTTP6.jpg\" alt=\"\" title=\"\" /></p>\n\n<h4 id=\"\">管道化</h4>\n\n<p>如果一个http请求，请求了大量的图片等大文件，那么其他的http请求怎么办呢？http可以一次发送多个http请求，然后等待响应连接。不需要排队等候，这样就加快了http的响应时间。</p>\n\n<h4 id=\"\">内容编码</h4>\n\n<p>由于某些报文的内容过大，因此在传输时，为了减少传输的时间，会采取一些压缩的措施。如上面的报文信息中，Accept-Encoding就定义了内容编码的格式：gzip</p>\n\n<hr />\n\n<h4 id=\"\">其他传输方式</h4>\n\n<ul>\n<li>PUT：传输文件，在请求报文的主体中包含文件内容，然后保存到请求URL指定的位置，有安全问题；</li>\n<li>HEAD：获得报文首部，不返回报文主体部分，用于确认URI的有效性及资源更新的日期时间等；</li>\n<li>DELETE：删除文件，DELETE是与PUT相反的方法，是按请求URI删除指定的资源</li>\n<li>OPYIONS：询问支持的方法，用来查询针对请求URI指定的资源支持的方法</li>\n<li>TRACE：追踪路径，让web服务器端将之前的请求通信还回给客户端的方法，发送请求时，在Max-Frowards首部字段中填入数值，每经过一个服务器端就-1，当数值为0时，停止传输，最后收到服务器返回状态码200 OK的响应</li>\n<li>CONNECT：要求采用隧道协议连接代理，该方法要求在于代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经过网络传输。</li>\n</ul>","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-25 07:59:13","created_by":1,"updated_at":"2017-05-25 08:07:18","updated_by":1,"published_at":"2017-05-25 08:07:05","published_by":1},{"id":15,"uuid":"612c5836-740c-4833-9080-1fbac1e6bed6","title":"HTTP状态码","slug":"httpzhuang-tai-ma","markdown":"#![](/assets/images/2017/http.jpg)\n\n\n####1** \n* 100 (Continue/继续)：如果服务器收到头信息中带有100-continue的请求，这是指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100(SC_CONTINUE)允许客户端继续或用417 (Expectation Failed)告诉客户端不同意接受附件。\n* 101 (Switching Protocols/转换协议)：指服务器将按照其头信息变为一个不同的协议。\n\n---\n####2** \n* 200 (OK/正常)：一切正常。一般用于相应GET和POST请求。这个状态码对servlet是缺省的；如果没有调用setStatus方法的话，就会得到200。\n* 201 (Created/已创建)：表示服务器在请求的响应中建立了新文档；应在定位头信息中给出它的URL。\n* 202 (Accepted/接受)：)告诉客户端请求正在被执行，但还没有处理完。 \n* 203 (Non-Authoritative Information/非官方信息)：表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确。\n* 204 (No Content/无内容)：无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档\n* 205 (Reset Content/重置内容)：重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。 \n* 206 (Partial Content/局部内容)：部分内容。服务器成功处理了部分GET请求\n\n---\n####3** \n* 300 (Multiple Choices/多重选择)：多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择\n* 301 (Moved Permanently)：永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替\n* 302 (Found/找到)：临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI\n* 303 (See Other/参见其他信息)：查看其它地址。与301类似。使用GET和POST请求查看\n* 304 (Not Modified/为修正)：未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源\n* 305 (Use Proxy/使用代理)：使用代理。所请求的资源必须通过代理访问\n* 307 (Temporary Redirect/临时重定向)：临时重定向。与302类似。使用GET请求重定向。\n\n---\n####4** \n* 400 (Bad Request/错误请求)：客户端请求的语法错误，服务器无法理解；\n* 401 (Unauthorized/未授权)：请求要求用户的身份认证\n* 403 (Forbidden/禁止)：服务器理解请求客户端的请求，但是拒绝执行此请求\n* 404 (Not Found/未找到)：服务器无法根据客户端的请求找到资源（网页）。\n* 405 (Method Not Allowed/方法未允许)：客户端请求中的方法被禁止\n* 406 (Not Acceptable/无法访问)：服务器无法根据客户端请求的内容特性完成请求\n* 407 (Proxy Authentication Required/代理服务器认证要求)：请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权\n* 408 (Request Timeout/请求超时)：服务器等待客户端发送的请求时间过长，超时\n* 409 (Conflict/冲突) 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突\n* 410 (Gone/已经不存在)：客户端请求的资源已经不存在。\n* 411 (Length Required/需要数据长度)：服务器无法处理客户端发送的不带Content-Length的请求信息\n* 412 (Precondition Failed/先决条件错误)：客户端请求信息的先决条件错误\n* 413 (Request Entity Too Large/请求实体过大)：由于请求的实体过大，服务器无法处理，因此拒绝请求。\n* 414 (Request URI Too Long/请求URI过长)：请求的URI过长（URI通常为网址），服务器无法处理\n* 415 (Unsupported Media Type/不支持的媒体格式)：服务器无法处理请求附带的媒体格式\n* 416 (Requested Range Not Satisfiable/请求范围无法满足)：客户端请求的范围无效\n* 417 (Expectation Failed/期望失败)：服务器无法满足Expect的请求头信息\n\n---\n####5** \n* 500 (Internal Server Error/内部服务器错误)：服务器内部错误，无法完成请求\n* 501 (Not Implemented/未实现)：服务器不支持请求的功能，无法完成请求\n* 502 (Bad Gateway/错误的网关)：接收服务器接收到远端服务器的错误响应\n* 503 (Service Unavailable/服务无法获得)：服务器由于在维护或已经超载而无法响应。\n* 504 (Gateway Timeout/网关超时)：接收服务器没有从远端服务器得到及时的响应。\n* 505 (HTTP Version Not Supported/不支持的 HTTP 版本)：\n\n---\n","mobiledoc":null,"html":"<h1 id=\"contentimages201705httpjpg\"><img src=\"/assets/images/2017/http.jpg\" alt=\"\" title=\"\" /></h1>\n\n<h4 id=\"1\">1**</h4>\n\n<ul>\n<li>100 (Continue/继续)：如果服务器收到头信息中带有100-continue的请求，这是指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100(SC_CONTINUE)允许客户端继续或用417 (Expectation Failed)告诉客户端不同意接受附件。</li>\n<li>101 (Switching Protocols/转换协议)：指服务器将按照其头信息变为一个不同的协议。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"2\">2**</h4>\n\n<ul>\n<li>200 (OK/正常)：一切正常。一般用于相应GET和POST请求。这个状态码对servlet是缺省的；如果没有调用setStatus方法的话，就会得到200。</li>\n<li>201 (Created/已创建)：表示服务器在请求的响应中建立了新文档；应在定位头信息中给出它的URL。</li>\n<li>202 (Accepted/接受)：)告诉客户端请求正在被执行，但还没有处理完。 </li>\n<li>203 (Non-Authoritative Information/非官方信息)：表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确。</li>\n<li>204 (No Content/无内容)：无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li>\n<li>205 (Reset Content/重置内容)：重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。 </li>\n<li>206 (Partial Content/局部内容)：部分内容。服务器成功处理了部分GET请求</li>\n</ul>\n\n<hr />\n\n<h4 id=\"3\">3**</h4>\n\n<ul>\n<li>300 (Multiple Choices/多重选择)：多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</li>\n<li>301 (Moved Permanently)：永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li>\n<li>302 (Found/找到)：临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li>\n<li>303 (See Other/参见其他信息)：查看其它地址。与301类似。使用GET和POST请求查看</li>\n<li>304 (Not Modified/为修正)：未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li>\n<li>305 (Use Proxy/使用代理)：使用代理。所请求的资源必须通过代理访问</li>\n<li>307 (Temporary Redirect/临时重定向)：临时重定向。与302类似。使用GET请求重定向。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"4\">4**</h4>\n\n<ul>\n<li>400 (Bad Request/错误请求)：客户端请求的语法错误，服务器无法理解；</li>\n<li>401 (Unauthorized/未授权)：请求要求用户的身份认证</li>\n<li>403 (Forbidden/禁止)：服务器理解请求客户端的请求，但是拒绝执行此请求</li>\n<li>404 (Not Found/未找到)：服务器无法根据客户端的请求找到资源（网页）。</li>\n<li>405 (Method Not Allowed/方法未允许)：客户端请求中的方法被禁止</li>\n<li>406 (Not Acceptable/无法访问)：服务器无法根据客户端请求的内容特性完成请求</li>\n<li>407 (Proxy Authentication Required/代理服务器认证要求)：请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</li>\n<li>408 (Request Timeout/请求超时)：服务器等待客户端发送的请求时间过长，超时</li>\n<li>409 (Conflict/冲突) 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</li>\n<li>410 (Gone/已经不存在)：客户端请求的资源已经不存在。</li>\n<li>411 (Length Required/需要数据长度)：服务器无法处理客户端发送的不带Content-Length的请求信息</li>\n<li>412 (Precondition Failed/先决条件错误)：客户端请求信息的先决条件错误</li>\n<li>413 (Request Entity Too Large/请求实体过大)：由于请求的实体过大，服务器无法处理，因此拒绝请求。</li>\n<li>414 (Request URI Too Long/请求URI过长)：请求的URI过长（URI通常为网址），服务器无法处理</li>\n<li>415 (Unsupported Media Type/不支持的媒体格式)：服务器无法处理请求附带的媒体格式</li>\n<li>416 (Requested Range Not Satisfiable/请求范围无法满足)：客户端请求的范围无效</li>\n<li>417 (Expectation Failed/期望失败)：服务器无法满足Expect的请求头信息</li>\n</ul>\n\n<hr />\n\n<h4 id=\"5\">5**</h4>\n\n<ul>\n<li>500 (Internal Server Error/内部服务器错误)：服务器内部错误，无法完成请求</li>\n<li>501 (Not Implemented/未实现)：服务器不支持请求的功能，无法完成请求</li>\n<li>502 (Bad Gateway/错误的网关)：接收服务器接收到远端服务器的错误响应</li>\n<li>503 (Service Unavailable/服务无法获得)：服务器由于在维护或已经超载而无法响应。</li>\n<li>504 (Gateway Timeout/网关超时)：接收服务器没有从远端服务器得到及时的响应。</li>\n<li>505 (HTTP Version Not Supported/不支持的 HTTP 版本)：</li>\n</ul>\n\n<hr />","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-25 08:08:15","created_by":1,"updated_at":"2017-05-25 08:11:25","updated_by":1,"published_at":"2017-05-25 08:11:25","published_by":1},{"id":16,"uuid":"161ca586-b0cd-4404-8ab6-8782ae07f549","title":"HTML--基础","slug":"html","markdown":"####Doctype\n* 标准模式与兼容模式各有什么区别? \n * <!DOCTYPE>声明位于位于HTML文档中的第一行，处于<html>标签之前，告知浏览器的解析器用什么文档标准解析这个文档。\n * DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。\n* HTML5 为什么只需要写 <!DOCTYPE HTML>?\n * HTML5 不基于标准通用标记语言SGML(Standard Generalized Markup language)，因此不需要对DTD(Document Type Definition)进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；\n * 而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。\n\n---\n####标签元素\t\n* 行内元素有哪些？块级元素有哪些？空(void)元素有那些？\n * CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为`block`，则为块级元素；span默认display属性值为`inline`，是行内元素。\n * 行内元素有：`a` `b` `span` `img` `input` `select` `strong`\n * 块级元素有：`div` `ul` `ol` `li` `dl` `dt` `dd` `h1` `h2` `h3` `h4`\n * 常见的空元素：`br` `hr` `img` `input` `link` `meta`\n * 鲜为人知的是：`area` `base` `col` `command` `embed` `keygen` `param` `source` `track` `wbr`\n\n---\n####页面导入样式时，使用link和@import有什么区别？\n* link属于XHTML标签，除了加载CSS外，还能用于定义RSS，定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS；\n* 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载；\n* import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。\n\n---\n####浏览器内核\n* 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。\n* 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。\n* JS引擎则：解析和执行javascript来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。\n* 常见的浏览器内核有哪些？\n * Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]；\n * Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等；\n * Presto内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink;]；\n * Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）]\n\n---\n####HTML5新特性\n ![](/assets/images/2017/h1.jpg)\n\n用webWorker来处理一些比较耗时的计算，postMessage(data)：子线程与主线程之间互相通信使用方法，传递的data为任意值。terminate()：主线程中终止worker，此后无法再利用其进行消息传递。\n\n---\n\n####HTML5的离线储存\n* 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。\n* 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。\n* 如何使用\n * 页面头部像下面一样加入一个manifest的属性；\n * 在cache.manifest文件的编写离线存储的资源；\n * 在离线状态时，操作window.applicationCache进行需求实现。\n######CACHE MANIFEST\n    v0.11\n    CACHE:\n        js/app.js\n        css/style.css\n    NETWORK:\n        resourse/logo.png\n    FALLBACK:\n        //offline.html\n\n####浏览器对HTML5的离线储存资源进行管理和加载\n* 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件。\n* 如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。\n* 如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。离线的情况下，浏览器就直接使用离线存储的资源。\n\n---\n####cookies、sessionStorage 和 localStorage \n* cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密），cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。\n* 存储大小：cookie数据大小不能超过4k。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n* 有期时间：localStorage：存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage：数据在当前浏览器窗口关闭后自动删除。Cookie：设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。\n\n---\n####Iframe\n* window 的 onload 事件需要在所有 iframe 加载完毕后(包含里面的元素)才会触发。iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。\n* 搜索引擎的检索程序无法解读这种页面，不利于SEO(Search Engine Optimization);\n* 如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。\n\n----\n####Label\n* Label标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。\n* `<label for=\"Name\">Number:</label>`\n* `<input type=“text“name=\"Name\" id=\"Name\"/>`\n* `<label>Date:<input type=\"text\" name=\"B\"/></label>`\n\n####HTML5的form关闭自动完成功能\n* 给不想要提示的 form 或某个 input 设置为 `autocomplete=off`。\n\n---\n####浏览器内多个标签页之间的通信\n* WebSocket、SharedWorker；\n* 可以调用localstorge、cookies等本地存储方式；\n* localstorge另一个浏览上下文里被添加、修改或删除时，它会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信；\n> ![](/assets/images/2017/h2.jpg)\n> ![](/assets/images/2017/h3.jpg)\n \n* webSocket：ajax轮询 需要服务器有很快的处理速度和资源。（速度）long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）就变成了这样，只需要经过一次HTTP请求，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你 ）\n* 如何兼容低浏览器？(阿里) Adobe Flash Socket 、ActiveX HTMLFile (IE) 、基于 multipart 编码发送 XHR 、基于长轮询的 XHR\n\n---\n####页面可见性（Page Visibility API） \n* 通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；\n ![](/assets/images/2017/h4.jpg)\n\n---\n####在页面上实现一个圆形的可点击区域\n* map+area或者svg；\n* border-radius；\n* 纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等\n\n ![](/assets/images/2017/h5.jpg)\n ![](/assets/images/2017/h6.jpg)\n ![](/assets/images/2017/h7.jpg)\n\n   \n####画线\n* 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。\n* `<div style=\"height:1px;overflow:hidden;background:red\"></div>`\n\n####网页验证码\n* 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；\n* 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。\n\n\n####title与h1、b与strong、i与em的区别\n* `title`属性没有明确意义只表示是个标题，`H1`则表示层次明确的标题，对页面信息的抓取也有很大的影响；\n* `strong`是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：`<strong>`会重读，而`<B>`是展示强调内容。\n* `i`内容展示为斜体，`em`表示强调的文本；\n* Physical Style Elements，自然样式标签b, i, u, s, pre；\n* Semantic Style Elements，语义样式标签strong, em, ins, del, code；\n* 应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。\n\n---\n####canvas与svg\n* canvas：元素本身并没有绘制能力（它仅仅是图形的容器），必须使用脚本来完成实际的绘图任务。Canvas提供的功能更原始，适合像素处理，动态渲染和大数据量绘制。\n* SVG可缩放矢量图形（Scalable Vector Graphics）：基于可扩展标记语言（XML），使用XML文档描述来绘图。SVG功能更完善，适合静态图片展示，高保真文档查看和打印的应用场景。\n ![](/assets/images/2017/h8.jpg)\n\n---\n####缓存清除\n如何处理缓存，如何清除缓存：浏览器的缓存，有的时候我们需要它来提高网站性能和浏览器速度；但有的时候我们又不得不清除缓存，因为缓存中可能包含一些错误的数据，因此，缓存比较适用于较少更新的网站。\n\n* meta方法\n >![](/assets/images/2017/h9.jpg)\n\n* 清理form表单的临时缓存：\n`<body onLoad=\"javascript:document.yourFormName.reset()\">`\n* jquery ajax清除浏览器缓存\n * 用ajax请求服务器最新文件，并加上请求头`If-Modified-Since`和`Cache-Control`\n![](/assets/images/2017/h10.jpg)![](/assets/images/2017/h11.jpg)\n * 直接用cache:false\n * 用随机数：URL 参数后加上 `\"?ran=\" + Math.random()`;\n* 用php后端清理：在服务端加 `header(\"Cache-Control: no-cache, must-revalidate\")`\n\n---\n","mobiledoc":null,"html":"<h4 id=\"doctype\">Doctype</h4>\n\n<ul>\n<li>标准模式与兼容模式各有什么区别? \n<ul><li><!DOCTYPE>声明位于位于HTML文档中的第一行，处于<html>标签之前，告知浏览器的解析器用什么文档标准解析这个文档。</li>\n<li>DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</li></ul></li>\n<li>HTML5 为什么只需要写 <!DOCTYPE HTML>?\n<ul><li>HTML5 不基于标准通用标记语言SGML(Standard Generalized Markup language)，因此不需要对DTD(Document Type Definition)进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；</li>\n<li>而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</li></ul></li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">标签元素</h4>\n\n<ul>\n<li>行内元素有哪些？块级元素有哪些？空(void)元素有那些？\n<ul><li>CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为<code>block</code>，则为块级元素；span默认display属性值为<code>inline</code>，是行内元素。</li>\n<li>行内元素有：<code>a</code> <code>b</code> <code>span</code> <code>img</code> <code>input</code> <code>select</code> <code>strong</code></li>\n<li>块级元素有：<code>div</code> <code>ul</code> <code>ol</code> <code>li</code> <code>dl</code> <code>dt</code> <code>dd</code> <code>h1</code> <code>h2</code> <code>h3</code> <code>h4</code></li>\n<li>常见的空元素：<code>br</code> <code>hr</code> <code>img</code> <code>input</code> <code>link</code> <code>meta</code></li>\n<li>鲜为人知的是：<code>area</code> <code>base</code> <code>col</code> <code>command</code> <code>embed</code> <code>keygen</code> <code>param</code> <code>source</code> <code>track</code> <code>wbr</code></li></ul></li>\n</ul>\n\n<hr />\n\n<h4 id=\"linkimport\">页面导入样式时，使用link和@import有什么区别？</h4>\n\n<ul>\n<li>link属于XHTML标签，除了加载CSS外，还能用于定义RSS，定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS；</li>\n<li>页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载；</li>\n<li>import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">浏览器内核</h4>\n\n<ul>\n<li>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。</li>\n<li>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</li>\n<li>JS引擎则：解析和执行javascript来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</li>\n<li>常见的浏览器内核有哪些？\n<ul><li>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]；</li>\n<li>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等；</li>\n<li>Presto内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink;]；</li>\n<li>Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）]</li></ul></li>\n</ul>\n\n<hr />\n\n<h4 id=\"html5\">HTML5新特性</h4>\n\n<p><img src=\"/assets/images/2017/h1.jpg\" alt=\"\" title=\"\" /></p>\n\n<p>用webWorker来处理一些比较耗时的计算，postMessage(data)：子线程与主线程之间互相通信使用方法，传递的data为任意值。terminate()：主线程中终止worker，此后无法再利用其进行消息传递。</p>\n\n<hr />\n\n<h4 id=\"html5\">HTML5的离线储存</h4>\n\n<ul>\n<li>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</li>\n<li>原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</li>\n<li>如何使用\n<ul><li>页面头部像下面一样加入一个manifest的属性；</li>\n<li>在cache.manifest文件的编写离线存储的资源；</li>\n<li>在离线状态时，操作window.applicationCache进行需求实现。</li></ul></li>\n</ul>\n\n<h6 id=\"cachemanifest\">CACHE MANIFEST</h6>\n\n<pre><code>v0.11\nCACHE:\n    js/app.js\n    css/style.css\nNETWORK:\n    resourse/logo.png\nFALLBACK:\n    //offline.html\n</code></pre>\n\n<h4 id=\"html5\">浏览器对HTML5的离线储存资源进行管理和加载</h4>\n\n<ul>\n<li>在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件。</li>\n<li>如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。</li>\n<li>如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。离线的情况下，浏览器就直接使用离线存储的资源。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"cookiessessionstoragelocalstorage\">cookies、sessionStorage 和 localStorage</h4>\n\n<ul>\n<li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密），cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li>\n<li>存储大小：cookie数据大小不能超过4k。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>\n<li>有期时间：localStorage：存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage：数据在当前浏览器窗口关闭后自动删除。Cookie：设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"iframe\">Iframe</h4>\n\n<ul>\n<li>window 的 onload 事件需要在所有 iframe 加载完毕后(包含里面的元素)才会触发。iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li>\n<li>搜索引擎的检索程序无法解读这种页面，不利于SEO(Search Engine Optimization);</li>\n<li>如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"label\">Label</h4>\n\n<ul>\n<li>Label标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</li>\n<li><code>&lt;label for=\"Name\"&gt;Number:&lt;/label&gt;</code></li>\n<li><code>&lt;input type=“text“name=\"Name\" id=\"Name\"/&gt;</code></li>\n<li><code>&lt;label&gt;Date:&lt;input type=\"text\" name=\"B\"/&gt;&lt;/label&gt;</code></li>\n</ul>\n\n<h4 id=\"html5form\">HTML5的form关闭自动完成功能</h4>\n\n<ul>\n<li>给不想要提示的 form 或某个 input 设置为 <code>autocomplete=off</code>。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">浏览器内多个标签页之间的通信</h4>\n\n<ul>\n<li>WebSocket、SharedWorker；</li>\n<li>可以调用localstorge、cookies等本地存储方式；</li>\n<li><p>localstorge另一个浏览上下文里被添加、修改或删除时，它会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信；</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/h2.jpg\" alt=\"\" title=\"\" />\n  <img src=\"/assets/images/2017/h3.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote></li>\n<li><p>webSocket：ajax轮询 需要服务器有很快的处理速度和资源。（速度）long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）就变成了这样，只需要经过一次HTTP请求，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你 ）</p></li>\n<li>如何兼容低浏览器？(阿里) Adobe Flash Socket 、ActiveX HTMLFile (IE) 、基于 multipart 编码发送 XHR 、基于长轮询的 XHR</li>\n</ul>\n\n<hr />\n\n<h4 id=\"pagevisibilityapi\">页面可见性（Page Visibility API）</h4>\n\n<ul>\n<li>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；\n<img src=\"/assets/images/2017/h4.jpg\" alt=\"\" title=\"\" /></li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">在页面上实现一个圆形的可点击区域</h4>\n\n<ul>\n<li>map+area或者svg；</li>\n<li>border-radius；</li>\n<li><p>纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</p>\n\n<p><img src=\"/assets/images/2017/h5.jpg\" alt=\"\" title=\"\" />\n<img src=\"/assets/images/2017/h6.jpg\" alt=\"\" title=\"\" />\n<img src=\"/assets/images/2017/h7.jpg\" alt=\"\" title=\"\" /></p></li>\n</ul>\n\n<h4 id=\"\">画线</h4>\n\n<ul>\n<li>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</li>\n<li><code>&lt;div style=\"height:1px;overflow:hidden;background:red\"&gt;&lt;/div&gt;</code></li>\n</ul>\n\n<h4 id=\"\">网页验证码</h4>\n\n<ul>\n<li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；</li>\n<li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</li>\n</ul>\n\n<h4 id=\"titleh1bstrongiem\">title与h1、b与strong、i与em的区别</h4>\n\n<ul>\n<li><code>title</code>属性没有明确意义只表示是个标题，<code>H1</code>则表示层次明确的标题，对页面信息的抓取也有很大的影响；</li>\n<li><code>strong</code>是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<code>&lt;strong&gt;</code>会重读，而<code>&lt;B&gt;</code>是展示强调内容。</li>\n<li><code>i</code>内容展示为斜体，<code>em</code>表示强调的文本；</li>\n<li>Physical Style Elements，自然样式标签b, i, u, s, pre；</li>\n<li>Semantic Style Elements，语义样式标签strong, em, ins, del, code；</li>\n<li>应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"canvassvg\">canvas与svg</h4>\n\n<ul>\n<li>canvas：元素本身并没有绘制能力（它仅仅是图形的容器），必须使用脚本来完成实际的绘图任务。Canvas提供的功能更原始，适合像素处理，动态渲染和大数据量绘制。</li>\n<li>SVG可缩放矢量图形（Scalable Vector Graphics）：基于可扩展标记语言（XML），使用XML文档描述来绘图。SVG功能更完善，适合静态图片展示，高保真文档查看和打印的应用场景。\n<img src=\"/assets/images/2017/h8.jpg\" alt=\"\" title=\"\" /></li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">缓存清除</h4>\n\n<p>如何处理缓存，如何清除缓存：浏览器的缓存，有的时候我们需要它来提高网站性能和浏览器速度；但有的时候我们又不得不清除缓存，因为缓存中可能包含一些错误的数据，因此，缓存比较适用于较少更新的网站。</p>\n\n<ul>\n<li><p>meta方法</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/h9.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote></li>\n<li><p>清理form表单的临时缓存：\n<code>&lt;body onLoad=\"javascript:document.yourFormName.reset()\"&gt;</code></p></li>\n<li>jquery ajax清除浏览器缓存\n<ul><li>用ajax请求服务器最新文件，并加上请求头<code>If-Modified-Since</code>和<code>Cache-Control</code>\n<img src=\"/assets/images/2017/h10.jpg\" alt=\"\" title=\"\" /><img src=\"/assets/images/2017/h11.jpg\" alt=\"\" title=\"\" /></li>\n<li>直接用cache:false</li>\n<li>用随机数：URL 参数后加上 <code>\"?ran=\" + Math.random()</code>;</li></ul></li>\n<li>用php后端清理：在服务端加 <code>header(\"Cache-Control: no-cache, must-revalidate\")</code></li>\n</ul>\n\n<hr />","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-25 08:11:56","created_by":1,"updated_at":"2017-05-25 08:49:28","updated_by":1,"published_at":"2017-05-25 08:49:28","published_by":1},{"id":17,"uuid":"5f668386-d738-40cf-9201-8a14a7c588d2","title":"前端性能","slug":"qian-duan-xing-neng","markdown":"####基本概念\n* 从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验；\n* 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。\n####优化途径\n* 按粒度大致可以分为两类，第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等；\n* 第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。\n* 减少 HTTP请求数：一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。\n * 页面简单，不需要过多的修饰；\n * 合理设置 HTTP缓存：被缓存资源的请求服务器是 304响应，只有 Header没有Body ，可以节省带宽\n * 资源合并与压缩：如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。另外， CSS、 Javascript、Image 都可以用相应的工具进行压缩，压缩后往往能省下不少空间。\n* 将外部脚本置底（将脚本内容在页面信息内容加载后再加载）\n * 外链脚本在加载时却会阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载。\n* 异步执行 inline脚本(其实原理和上面是一样，保证脚本在页面内容后面加载。)\n* 将 CSS放在 HEAD中\n * 如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，用户体验比较糟糕。\n * 除此之外，有些浏览器会在 CSS下载完成后才开始渲染页面，如果 CSS放在靠下的位置则会导致浏览器将渲染时间推迟。\n* DOM 操作优化：DOM操作应该是脚本中最耗性能的一类操作，例如增加、修改、删除 DOM元素或者对 DOM集合进行操作。\n * 需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。即使不转换为数组，也请尽可能少的访问它，例如在遍历的时候可以将 length属性、成员保存到局部变量后再使用局部变量。每次使用时都要重新执行查询得到结果；\n * Reflow & Repaint：不要一条一条地修改 DOM 的样式；\n * 慎用 with、避免使用 eval和 Function、减少作用域链、查找数据访问。\n* CSS选择符\n* HTML\n* Image压缩\n\n---\n","mobiledoc":null,"html":"<h4 id=\"\">基本概念</h4>\n\n<ul>\n<li>从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验；</li>\n<li>从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。</li>\n</ul>\n\n<h4 id=\"\">优化途径</h4>\n\n<ul>\n<li>按粒度大致可以分为两类，第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等；</li>\n<li>第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。</li>\n<li>减少 HTTP请求数：一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。\n<ul><li>页面简单，不需要过多的修饰；</li>\n<li>合理设置 HTTP缓存：被缓存资源的请求服务器是 304响应，只有 Header没有Body ，可以节省带宽</li>\n<li>资源合并与压缩：如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。另外， CSS、 Javascript、Image 都可以用相应的工具进行压缩，压缩后往往能省下不少空间。</li></ul></li>\n<li>将外部脚本置底（将脚本内容在页面信息内容加载后再加载）\n<ul><li>外链脚本在加载时却会阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载。</li></ul></li>\n<li>异步执行 inline脚本(其实原理和上面是一样，保证脚本在页面内容后面加载。)</li>\n<li>将 CSS放在 HEAD中\n<ul><li>如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，用户体验比较糟糕。</li>\n<li>除此之外，有些浏览器会在 CSS下载完成后才开始渲染页面，如果 CSS放在靠下的位置则会导致浏览器将渲染时间推迟。</li></ul></li>\n<li>DOM 操作优化：DOM操作应该是脚本中最耗性能的一类操作，例如增加、修改、删除 DOM元素或者对 DOM集合进行操作。\n<ul><li>需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。即使不转换为数组，也请尽可能少的访问它，例如在遍历的时候可以将 length属性、成员保存到局部变量后再使用局部变量。每次使用时都要重新执行查询得到结果；</li>\n<li>Reflow &amp; Repaint：不要一条一条地修改 DOM 的样式；</li>\n<li>慎用 with、避免使用 eval和 Function、减少作用域链、查找数据访问。</li></ul></li>\n<li>CSS选择符</li>\n<li>HTML</li>\n<li>Image压缩</li>\n</ul>\n\n<hr />","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-26 00:41:22","created_by":1,"updated_at":"2017-05-26 00:46:54","updated_by":1,"published_at":"2017-05-26 00:42:09","published_by":1},{"id":18,"uuid":"5b7fc258-0d0b-4051-8b8b-e70b58bb0566","title":"前后端联合开发","slug":"qian-hou-duan-lian-he-kai-fa","markdown":"####开发流程\n* Front-end Integrated Solution（前端集成解决方案）\n* 规范与设计\n* 技术选型\n * 选择前端模块化框架（seajs, requirejs, ...）\n * 选择前端基础库（jquery, tangram, ...）\n * 选择模板语言（php, smarty, ...）\n * 选择模板插件（xss修复）\n* 自动化与拆分\n * 选择或开发自动化工具（打包，压缩，校验）\n * 将系统拆分为几个子系统，以便大团队并行开发\n * 适当调整框架以适应工具产出\n* 性能优化\n####前后端分离与协同\n* 一种是前端先写一个静态页面，写好后，让后端去套模板。静态页面可以本地开发，也无需考虑业务逻辑只需要实现View即可。不足是还需要后端套模板，这些前端代码后端需要浏览一遍，以免出错。\n* 另一种协作模式是，前端直接去写模板，这样做的问题在于，前端编写过程中很依赖与后端环境，如果当后端没写完的情况下，前端几乎没法干活。\n* 中间件，基于NodeJS的前后端分离\n####页面优化\n* 从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。\n* 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。\n* 前端优化的途径有很多，按粒度大致可以分为两类，第一类是页面级别的优化，例如HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等;第二类则是代码级别的优化，例如Javascript中的DOM操作优化、CSS选择符优化、图片优化以及HTML结构优化等等。\n####HTML语义化\n* 根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。\n####AJAX\n* 通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加`<script>`标签来调用服务器提供的js脚本。\n####模块化\n* 解决命名冲突（YUI ）、文件依赖（Sea.js）\n* 数据模块的加载\n* 解析模块的层次依赖关系\n* 添加事件机制，优化管理代码\n\n---\n","mobiledoc":null,"html":"<h4 id=\"\">开发流程</h4>\n\n<ul>\n<li>Front-end Integrated Solution（前端集成解决方案）</li>\n<li>规范与设计</li>\n<li>技术选型\n<ul><li>选择前端模块化框架（seajs, requirejs, ...）</li>\n<li>选择前端基础库（jquery, tangram, ...）</li>\n<li>选择模板语言（php, smarty, ...）</li>\n<li>选择模板插件（xss修复）</li></ul></li>\n<li>自动化与拆分\n<ul><li>选择或开发自动化工具（打包，压缩，校验）</li>\n<li>将系统拆分为几个子系统，以便大团队并行开发</li>\n<li>适当调整框架以适应工具产出</li></ul></li>\n<li>性能优化</li>\n</ul>\n\n<h4 id=\"\">前后端分离与协同</h4>\n\n<ul>\n<li>一种是前端先写一个静态页面，写好后，让后端去套模板。静态页面可以本地开发，也无需考虑业务逻辑只需要实现View即可。不足是还需要后端套模板，这些前端代码后端需要浏览一遍，以免出错。</li>\n<li>另一种协作模式是，前端直接去写模板，这样做的问题在于，前端编写过程中很依赖与后端环境，如果当后端没写完的情况下，前端几乎没法干活。</li>\n<li>中间件，基于NodeJS的前后端分离</li>\n</ul>\n\n<h4 id=\"\">页面优化</h4>\n\n<ul>\n<li>从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。</li>\n<li>从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。</li>\n<li>前端优化的途径有很多，按粒度大致可以分为两类，第一类是页面级别的优化，例如HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等;第二类则是代码级别的优化，例如Javascript中的DOM操作优化、CSS选择符优化、图片优化以及HTML结构优化等等。</li>\n</ul>\n\n<h4 id=\"html\">HTML语义化</h4>\n\n<ul>\n<li>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</li>\n</ul>\n\n<h4 id=\"ajax\">AJAX</h4>\n\n<ul>\n<li>通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。</li>\n</ul>\n\n<h4 id=\"\">模块化</h4>\n\n<ul>\n<li>解决命名冲突（YUI ）、文件依赖（Sea.js）</li>\n<li>数据模块的加载</li>\n<li>解析模块的层次依赖关系</li>\n<li>添加事件机制，优化管理代码</li>\n</ul>\n\n<hr />","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-26 00:48:08","created_by":1,"updated_at":"2017-05-26 00:50:52","updated_by":1,"published_at":"2017-05-26 00:50:52","published_by":1},{"id":19,"uuid":"78bbf9f9-6f8a-4935-b4c3-a8a502214218","title":"前端开发模式","slug":"qian-duan-kai-fa-mo-shi","markdown":"####工作模式\n* 图形界面的应用程序提供给用户可视化的操作界面，这个界面提供给数据和信息。\n* 用户输入行为（键盘，鼠标等）会执行一些业务逻辑，可能会导致对应用程序数据的变更，数据的变更自然需要用户界面的同步变更以提供最准确的信息。\n* View不仅要响应用户操作的业务逻辑，而且要同步Model的变更。![](/assets/images/2017/M1.jpg)\n\n---\n####MVC\n* 把应用程序分成View、Model层，还额外的加了一个Controller层，它的职责就是专门管理应用程序的业务逻辑。\n* 用户的对View操作以后，View捕获到这个操作，会把处理的权利交移给Controller（Pass calls）；Controller接着会执行相关的业务逻辑，这些业务逻辑可能需要对Model进行相应的操作；当Model变更了以后，会通过观察者模式（Observer Pattern）通知View；View通过观察者模式收到Model变更的消息以后，会向Model请求最新的数据，然后重新更新界面。\n * 把业务逻辑全部分离到Controller中，模块化程度高。当业务逻辑变更的时候，不需要变更View和Model，只需要Controller换成另外一个Controller就行了（Swappable Controller）。观察者模式可以做到多视图同时更新。\n * Controller测试困难。因为视图同步操作是由View自己执行，而View只能在有UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，Controller业务逻辑的正确性是无法验证的：Controller更新Model的时候，无法对View的更新操作进行断言。View无法组件化。View是强依赖特定的Model的，如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的Domain Model是不一样的。![](/assets/images/2017/M2.jpg)\n\n---\n####MVP\n* MVP打破了View原来对于Model的依赖，其余的依赖关系和MVC模式一致。\n* 用户对View的操作都会从View交移给Presenter。Presenter同样的会执行相应的业务逻辑，并且对Model进行相应的操作；而这时候Model也是通过观察者模式把自己变更的消息传递出去，但是是传给Presenter而不是View。Presenter获取到Model变更的消息以后，通过View提供的接口更新界面。\n * 便于测试。Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过模拟一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter业务逻辑的正确性；View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务逻辑完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做高度可复用的View组件。\n * Presenter中除了业务逻辑以外，还有大量的View->Model，Model->View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。![](/assets/images/2017/M3.jpg)\n\n---\n####MVVM\n* 可以看作是一种特殊的MVP（Passive View）模式，或者说是对MVP模式的一种改良。\n * MVVM的调用关系和MVP一样。但是，在ViewModel当中会有一个叫Binder，或者是Data-binding engine的东西。以前全部由Presenter负责的View和Model之间数据同步操作交由给Binder处理。你只需要在View的模版语法当中，指令式地声明View上的显示的内容是和Model的哪一块数据绑定的。当ViewModel对进行Model更新的时候，Binder会自动把数据更新到View上去，当用户对View进行操作（例如表单输入），Binder也会自动把数据更新到Model上去。这种方式称为：Two-way data-binding，双向数据绑定。可以简单而不恰当地理解为一个模版引擎，但是会根据数据变更实时渲染。\n * MVVM把View和Model的同步逻辑自动化了。以前Presenter负责的View和Model同步不再手动地进行操作，而是交由框架所提供的Binder进行负责。只需要告诉Binder，View显示的数据对应的是Model哪一部分即可。\n * 提高可维护性。解决了MVP大量的手动View和Model同步的问题，提供双向绑定机制。提高了代码的可维护性。简化测试。因为同步逻辑是交由Binder做的，View跟着Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。\n * 过于简单的图形界面不适用，或说牛刀杀鸡。对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的。![](/assets/images/2017/M4.jpg)\n\n---\n####SPA\n* single-page application，它将所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript 和 CSS。\n* 一旦页面加载完成了，SPA不会因为用户的操作而进行页面的重新加载或跳转。而是利用 JavaScript 动态的变换HTML的内（采用的是div切换显示和隐藏），从而实现UI与用户的交互。由于避免了页面的重新加载，SPA 可以提供较为流畅的用户体验。\n* 得益于ajax，我们可以实现无跳转刷新，又多亏了浏览器的histroy机制，我们用hash的变化从而可以实现推动界面变化。\n * 通过hashchange事件，我们可以监视#后面字符，一旦发生改变，就会触发此事件，也是大家常说的URL 的锚部分。\n * 局部刷新，这属于AJAX（阿贾克斯）的内容\n\n---\n####前端模板\n* 将 HTML 代码（View 层）和 JS 代码（Controller 层）混杂在了一起，UI 与逻辑代码混杂在一起，阅读起来会非常吃力。一旦业务复杂起来，或者多人维护的情况下，几乎会失控。\n*而且如果需要拼接的 HTML 代码里有很多引号的话（比如有大量的 href 属性，src 属性），那么就非常容易出错了（这样干过的应该深有体会）。这样一来，如果前端需要改 HTML 代码，只需要改模板即可。这样做的优点很明显，前端 UI 和逻辑代码不再混杂，阅读体验良好，改动起来也方便了许多。\n> ![](/assets/images/2017/M5.jpg)\n>\n> ![](/assets/images/2017/m6.jpg)\n\n---\n  \n","mobiledoc":null,"html":"<h4 id=\"\">工作模式</h4>\n\n<ul>\n<li>图形界面的应用程序提供给用户可视化的操作界面，这个界面提供给数据和信息。</li>\n<li>用户输入行为（键盘，鼠标等）会执行一些业务逻辑，可能会导致对应用程序数据的变更，数据的变更自然需要用户界面的同步变更以提供最准确的信息。</li>\n<li>View不仅要响应用户操作的业务逻辑，而且要同步Model的变更。<img src=\"/assets/images/2017/M1.jpg\" alt=\"\" title=\"\" /></li>\n</ul>\n\n<hr />\n\n<h4 id=\"mvc\">MVC</h4>\n\n<ul>\n<li>把应用程序分成View、Model层，还额外的加了一个Controller层，它的职责就是专门管理应用程序的业务逻辑。</li>\n<li>用户的对View操作以后，View捕获到这个操作，会把处理的权利交移给Controller（Pass calls）；Controller接着会执行相关的业务逻辑，这些业务逻辑可能需要对Model进行相应的操作；当Model变更了以后，会通过观察者模式（Observer Pattern）通知View；View通过观察者模式收到Model变更的消息以后，会向Model请求最新的数据，然后重新更新界面。\n<ul><li>把业务逻辑全部分离到Controller中，模块化程度高。当业务逻辑变更的时候，不需要变更View和Model，只需要Controller换成另外一个Controller就行了（Swappable Controller）。观察者模式可以做到多视图同时更新。</li>\n<li>Controller测试困难。因为视图同步操作是由View自己执行，而View只能在有UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，Controller业务逻辑的正确性是无法验证的：Controller更新Model的时候，无法对View的更新操作进行断言。View无法组件化。View是强依赖特定的Model的，如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的Domain Model是不一样的。<img src=\"/assets/images/2017/M2.jpg\" alt=\"\" title=\"\" /></li></ul></li>\n</ul>\n\n<hr />\n\n<h4 id=\"mvp\">MVP</h4>\n\n<ul>\n<li>MVP打破了View原来对于Model的依赖，其余的依赖关系和MVC模式一致。</li>\n<li>用户对View的操作都会从View交移给Presenter。Presenter同样的会执行相应的业务逻辑，并且对Model进行相应的操作；而这时候Model也是通过观察者模式把自己变更的消息传递出去，但是是传给Presenter而不是View。Presenter获取到Model变更的消息以后，通过View提供的接口更新界面。\n<ul><li>便于测试。Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过模拟一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter业务逻辑的正确性；View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务逻辑完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做高度可复用的View组件。</li>\n<li>Presenter中除了业务逻辑以外，还有大量的View->Model，Model->View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。<img src=\"/assets/images/2017/M3.jpg\" alt=\"\" title=\"\" /></li></ul></li>\n</ul>\n\n<hr />\n\n<h4 id=\"mvvm\">MVVM</h4>\n\n<ul>\n<li>可以看作是一种特殊的MVP（Passive View）模式，或者说是对MVP模式的一种改良。\n<ul><li>MVVM的调用关系和MVP一样。但是，在ViewModel当中会有一个叫Binder，或者是Data-binding engine的东西。以前全部由Presenter负责的View和Model之间数据同步操作交由给Binder处理。你只需要在View的模版语法当中，指令式地声明View上的显示的内容是和Model的哪一块数据绑定的。当ViewModel对进行Model更新的时候，Binder会自动把数据更新到View上去，当用户对View进行操作（例如表单输入），Binder也会自动把数据更新到Model上去。这种方式称为：Two-way data-binding，双向数据绑定。可以简单而不恰当地理解为一个模版引擎，但是会根据数据变更实时渲染。</li>\n<li>MVVM把View和Model的同步逻辑自动化了。以前Presenter负责的View和Model同步不再手动地进行操作，而是交由框架所提供的Binder进行负责。只需要告诉Binder，View显示的数据对应的是Model哪一部分即可。</li>\n<li>提高可维护性。解决了MVP大量的手动View和Model同步的问题，提供双向绑定机制。提高了代码的可维护性。简化测试。因为同步逻辑是交由Binder做的，View跟着Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。</li>\n<li>过于简单的图形界面不适用，或说牛刀杀鸡。对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的。<img src=\"/assets/images/2017/M4.jpg\" alt=\"\" title=\"\" /></li></ul></li>\n</ul>\n\n<hr />\n\n<h4 id=\"spa\">SPA</h4>\n\n<ul>\n<li>single-page application，它将所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript 和 CSS。</li>\n<li>一旦页面加载完成了，SPA不会因为用户的操作而进行页面的重新加载或跳转。而是利用 JavaScript 动态的变换HTML的内（采用的是div切换显示和隐藏），从而实现UI与用户的交互。由于避免了页面的重新加载，SPA 可以提供较为流畅的用户体验。</li>\n<li>得益于ajax，我们可以实现无跳转刷新，又多亏了浏览器的histroy机制，我们用hash的变化从而可以实现推动界面变化。\n<ul><li>通过hashchange事件，我们可以监视#后面字符，一旦发生改变，就会触发此事件，也是大家常说的URL 的锚部分。</li>\n<li>局部刷新，这属于AJAX（阿贾克斯）的内容</li></ul></li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">前端模板</h4>\n\n<p><ul>\n<li>将 HTML 代码（View 层）和 JS 代码（Controller 层）混杂在了一起，UI 与逻辑代码混杂在一起，阅读起来会非常吃力。一旦业务复杂起来，或者多人维护的情况下，几乎会失控。\n*而且如果需要拼接的 HTML 代码里有很多引号的话（比如有大量的 href 属性，src 属性），那么就非常容易出错了（这样干过的应该深有体会）。这样一来，如果前端需要改 HTML 代码，只需要改模板即可。这样做的优点很明显，前端 UI 和逻辑代码不再混杂，阅读体验良好，改动起来也方便了许多。</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/M5.jpg\" alt=\"\" title=\"\" /></p>\n  \n  <img src=\"/assets/images/2017/m6.jpg\" alt=\"\" title=\"\" /></li>\n  </ul>\n  <hr />\n</blockquote>","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-26 00:53:25","created_by":1,"updated_at":"2017-05-26 01:02:31","updated_by":1,"published_at":"2017-05-26 01:01:22","published_by":1},{"id":20,"uuid":"e9c94de7-2510-4a3f-a1b3-601ba32d89fa","title":"浏览器渲染及加载","slug":"liu-lan-qi-xuan-ran-ji-jia-zai","markdown":"####什么叫加载（下载）？\n* 加载就是下载html文档的过程，本质是下载\n* 了解浏览器如何进行加载，我们可以在引用外部样式css文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。\n\n####什么叫渲染（显示）？\n* 渲染是浏览器根据html文档把html元素显示的过程\n* 了解浏览器如何进行渲染，我们可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。\n\n####什么叫解析（解释）？\n* 下载后的JavaScript文件，和css文件需要对Dom树进行修改，叫做解析过程，对javascript很多时候解析过程就是执行过程。\n* 了解浏览器如何进行解析，明白渲染的过程，我们在设置元素属性，编写js文件时，可以减少“重绘”“重新布局”的消耗。\n\n这三个过程在实际进行的时候又不是完全独立，而是会有交叉。会造成一边加载，一边解析，一边渲染的工作现象。\n\n----\n####用户访问网页都发生了什么\n* DNS服务器（域名解析系统）会根据用户提供的域名查找对应的IP地址；\n* 客户端会向与对应IP地址的网络服务器建立TCP连接并发送一个http请求；\n* 网络服务器解析请求，并发送请求给数据库服务器，数据库服务器将请求的资源返回给网络服务器；\n* 网络服务器解析数据，并生成html文件，放入http response中，返回给浏览器；\n* 浏览器解析http response，下载html文件，以及html文件内包含的外部引用文件，及文件内涉及的图片或者多媒体文件。\n\n####浏览器渲染页面和解析加载页面机制\n* 当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。\n * 浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点；\n * 将CSS解析成 CSS Rule Tree 。\n * 根据DOM树和CSSOM来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。\n * 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。\n * 再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。\n* 上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。\n\n####回流与重绘\n* Reflow（回流）浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。\n* Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。Reflow要比Repaint更花费时间，也就更影响性能。所以在写代码的时候，要尽量避免过多的Reflow。\n* reflow的原因：\n * 页面初始化的时候； \n * 操作DOM时； \n * 某些元素的尺寸变了； \n * 如果 CSS 的属性发生变化了。\n* 减少 reflow/repaint\n * 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。 \n * 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。 \n * 为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。 \n * 千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。\n\n####HTML页面加载和解析流程 \n* 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件； \n* 浏览器开始载入html代码，发现`＜head＞`标签内有一个`＜link＞`标签引用外部CSS文件； \n* 浏览器又发出CSS文件的请求，服务器返回这个CSS文件； \n* 浏览器继续载入html中`＜body＞`部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了； \n* 浏览器在代码中发现一个`＜img＞`标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； \n* 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； \n* 浏览器发现了一个包含一行JavaScript代码的`＜script＞`标签，赶快运行它； \n* JavaScript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个`＜div＞ （style.display=”none”）`。突然少了这么一个元素，浏览器不得不重新渲染这部分代码； \n* 终于等到了`＜/html＞`的到来，浏览器泪流满面…… \n* 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下`＜link＞`标签的CSS路径； \n* 浏览器召集了在座的各位`＜div＞＜span＞＜ul＞＜li＞`们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。\n\n####CSS文件解析\n* CSS选择符是从右到左进行匹配的。从右到左！\n* 所以，`#nav li` 我们以为这是一条很简单的规则，秒秒钟就能匹配到想要的元素，但是，但是，但是，是从右往左匹配啊，所以，会去找所有的`li`，然后再去确定它的父元素是不是`#nav`。\n* 因此，写css的时候需要注意：\n * dom深度尽量浅\n * 减少inline javascript、css的数量。\n * 使用现代合法的css属性\n * 不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。\n * 避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;`#tp p{}` 子选择符：`#tp>p{}`\n * 避免使用通配符，举一个例子，`.mod .hd *{font-size:14px;}` 根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配`.hd`（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配`.mod`,这样的性能耗费可想而知.\n\n####Javascript的加载和执行的特点\n* 载入后马上执行；\n* 执行时会阻塞页面后续的内容（包括页面的渲染、其它资源的下载）。原因：因为浏览器需要一个稳定的DOM树结构，而JS中很有可能有 代码直接改变了DOM树结构，比如使用 document.write 或 appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修 改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现。\n* 减少 JavaScript 对性能的影响的方法\n * 将所有的script标签放到页面底部，也就是body闭合标签之前，这能确保在脚本执行前页面已经完成了DOM树渲染。\n * 尽可能地合并脚本。页面中的script标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。\n * 采用无阻塞下载 JavaScript 脚本的方法：等页面完成加载后，再加载js代码。也就是，在window.load事件发出后开始下载代码。带defer属性的<script>，动态脚本元素。\n\n---\n","mobiledoc":null,"html":"<h4 id=\"\">什么叫加载（下载）？</h4>\n\n<ul>\n<li>加载就是下载html文档的过程，本质是下载</li>\n<li>了解浏览器如何进行加载，我们可以在引用外部样式css文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。</li>\n</ul>\n\n<h4 id=\"\">什么叫渲染（显示）？</h4>\n\n<ul>\n<li>渲染是浏览器根据html文档把html元素显示的过程</li>\n<li>了解浏览器如何进行渲染，我们可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。</li>\n</ul>\n\n<h4 id=\"\">什么叫解析（解释）？</h4>\n\n<ul>\n<li>下载后的JavaScript文件，和css文件需要对Dom树进行修改，叫做解析过程，对javascript很多时候解析过程就是执行过程。</li>\n<li>了解浏览器如何进行解析，明白渲染的过程，我们在设置元素属性，编写js文件时，可以减少“重绘”“重新布局”的消耗。</li>\n</ul>\n\n<p>这三个过程在实际进行的时候又不是完全独立，而是会有交叉。会造成一边加载，一边解析，一边渲染的工作现象。</p>\n\n<hr />\n\n<h4 id=\"\">用户访问网页都发生了什么</h4>\n\n<ul>\n<li>DNS服务器（域名解析系统）会根据用户提供的域名查找对应的IP地址；</li>\n<li>客户端会向与对应IP地址的网络服务器建立TCP连接并发送一个http请求；</li>\n<li>网络服务器解析请求，并发送请求给数据库服务器，数据库服务器将请求的资源返回给网络服务器；</li>\n<li>网络服务器解析数据，并生成html文件，放入http response中，返回给浏览器；</li>\n<li>浏览器解析http response，下载html文件，以及html文件内包含的外部引用文件，及文件内涉及的图片或者多媒体文件。</li>\n</ul>\n\n<h4 id=\"\">浏览器渲染页面和解析加载页面机制</h4>\n\n<ul>\n<li>当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。\n<ul><li>浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点；</li>\n<li>将CSS解析成 CSS Rule Tree 。</li>\n<li>根据DOM树和CSSOM来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。</li>\n<li>有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。</li>\n<li>再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。</li></ul></li>\n<li>上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</li>\n</ul>\n\n<h4 id=\"\">回流与重绘</h4>\n\n<ul>\n<li>Reflow（回流）浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li>\n<li>Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。Reflow要比Repaint更花费时间，也就更影响性能。所以在写代码的时候，要尽量避免过多的Reflow。</li>\n<li>reflow的原因：\n<ul><li>页面初始化的时候； </li>\n<li>操作DOM时； </li>\n<li>某些元素的尺寸变了； </li>\n<li>如果 CSS 的属性发生变化了。</li></ul></li>\n<li>减少 reflow/repaint\n<ul><li>不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。 </li>\n<li>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。 </li>\n<li>为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。 </li>\n<li>千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</li></ul></li>\n</ul>\n\n<h4 id=\"html\">HTML页面加载和解析流程</h4>\n\n<ul>\n<li>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件； </li>\n<li>浏览器开始载入html代码，发现<code>＜head＞</code>标签内有一个<code>＜link＞</code>标签引用外部CSS文件； </li>\n<li>浏览器又发出CSS文件的请求，服务器返回这个CSS文件； </li>\n<li>浏览器继续载入html中<code>＜body＞</code>部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了； </li>\n<li>浏览器在代码中发现一个<code>＜img＞</code>标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； </li>\n<li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； </li>\n<li>浏览器发现了一个包含一行JavaScript代码的<code>＜script＞</code>标签，赶快运行它； </li>\n<li>JavaScript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个<code>＜div＞ （style.display=”none”）</code>。突然少了这么一个元素，浏览器不得不重新渲染这部分代码； </li>\n<li>终于等到了<code>＜/html＞</code>的到来，浏览器泪流满面…… </li>\n<li>等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下<code>＜link＞</code>标签的CSS路径； </li>\n<li>浏览器召集了在座的各位<code>＜div＞＜span＞＜ul＞＜li＞</code>们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。</li>\n</ul>\n\n<h4 id=\"css\">CSS文件解析</h4>\n\n<ul>\n<li>CSS选择符是从右到左进行匹配的。从右到左！</li>\n<li>所以，<code>#nav li</code> 我们以为这是一条很简单的规则，秒秒钟就能匹配到想要的元素，但是，但是，但是，是从右往左匹配啊，所以，会去找所有的<code>li</code>，然后再去确定它的父元素是不是<code>#nav</code>。</li>\n<li>因此，写css的时候需要注意：\n<ul><li>dom深度尽量浅</li>\n<li>减少inline javascript、css的数量。</li>\n<li>使用现代合法的css属性</li>\n<li>不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。</li>\n<li>避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;<code>#tp p{}</code> 子选择符：<code>#tp&gt;p{}</code></li>\n<li>避免使用通配符，举一个例子，<code>.mod .hd *{font-size:14px;}</code> 根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配<code>.hd</code>（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配<code>.mod</code>,这样的性能耗费可想而知.</li></ul></li>\n</ul>\n\n<h4 id=\"javascript\">Javascript的加载和执行的特点</h4>\n\n<ul>\n<li>载入后马上执行；</li>\n<li>执行时会阻塞页面后续的内容（包括页面的渲染、其它资源的下载）。原因：因为浏览器需要一个稳定的DOM树结构，而JS中很有可能有 代码直接改变了DOM树结构，比如使用 document.write 或 appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修 改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现。</li>\n<li>减少 JavaScript 对性能的影响的方法\n<ul><li>将所有的script标签放到页面底部，也就是body闭合标签之前，这能确保在脚本执行前页面已经完成了DOM树渲染。</li>\n<li>尽可能地合并脚本。页面中的script标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。</li>\n<li>采用无阻塞下载 JavaScript 脚本的方法：等页面完成加载后，再加载js代码。也就是，在window.load事件发出后开始下载代码。带defer属性的<script>，动态脚本元素。</li></ul></li>\n</ul>\n\n<hr />","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-26 01:04:04","created_by":1,"updated_at":"2017-05-26 01:19:16","updated_by":1,"published_at":"2017-05-26 01:19:16","published_by":1},{"id":21,"uuid":"1e23e3e3-08f3-492c-b7fe-f822fa7631bf","title":"前端框架","slug":"qian-duan-kuang-jia","markdown":"####Node.js\n* 并不是一门新的语言，与Java，PHP开发语言的平台也是不相同的，虽然他是JavaScript但是它并不是JavaScript的框架。\n* nodejs是让JavaScript运行在服务器端的开发平台。当一种事务在一个领域独孤求败的时候就会想着进入另外一个领域，JavaScript已经在近几年已经一统的前端的江湖，所以已经开始进入服务端的领域。\n* Node.js是基于Chrome JavaScript运行时建立的一个平台，使用C++编写的，实际上它是对Google Chrome V8引擎进行了封装，它主要用于创建快速的、可扩展的网络应用。\n* Node.js采用事件驱动和非阻塞I/O模型，使其变得轻微和高效，非常适合构建运行在分布式设备的数据密集型实时应用。\n\n---\n####Grunt\n* 自动化。\n* 对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting等，自动化工具可以减轻你的劳动，简化你的工作。\n* 当你在 Gruntfile 文件正确配置好了任务，任务运行器就会自动帮你或你的小组完成大部分无聊的工作。\n\n---\n####模块化工具\n* requirejs、seajs\n* 将一些属性比较类似和行为比较类似的内容放在同一个js文件里面，把这个js文件称为模块，了每个js文件只关注与自身有关的事情，让每个js文件各行其职；\n* MVC：veiw ( html + css + js )写静态页面 css、js、img及效果；controller ( 专注于实现服务和逻辑控制的层面叫做控制器 )监听页面中请求和事件，处理请求和事件；向model请求数据，得到数据后绑定到页面；model ( 数据变量 || ajax从服务端取回的数据 )对外提供一些数据\n* 命名冲突、文件依赖![](/assets/images/2017/k1.jpg)![](/assets/images/2017/k2.jpg)\n\n---\n  \n####类库\n* 解决的是代码或者是模块级别的复用或者对复杂度的封装问题，例如将一个解决复杂问题的功能模块封装成一个函数，提供一个简单的接口。\n* 它是一种工具，它提供了很多封装好的方法，用与不用取决于我们自身，即使用了也不会影响我们的代码结构。\n\n####框架\n* 对模式级别的复用和对程序组织的规范。这里的模式是指比如MVC，为了实现M和V的解耦，把复杂的耦合关系由经常变化的业务代码转移到不经常变化的框架内部消化。\n* 是面向一个领域来提供一套解决方案，提高开发效率，如果我们选择了使用某框架，就应该遵循该框架所规定的规则。\n\n####区别是\n* JQuery以DOM操作为中心，框架，准确来说是MVC框架，是以模型（model）为中心，而DOM操作是附加的。所以，以模型为中心最终达到的目的是带来一整套工作流程的变更，使得后台工程师可以编写前端的模型代码，把后台与前端打通，交互设计师处理UI跟模型的互动关系，UI设计师可以专注、无障碍的处理HTML源码，把它们以界面模板的形式提交给交互工程师。这一整套协作机制能大大提高开发效率。使用MVC框架使得前端任务更好的被解耦。\n\n---\n####BootStrap：UI框架\n* 响应式布局：响应式web布局是让用户通过不同尺寸的浏览器都可以获得良好视觉的一种方法。通过CSS3 Media Queries（媒体（设备）查询），媒体查询是让页面内容在不同的媒体环境下运行时可以展示不同的样式（这个样式当然是由我们来书写规定的）。@media是CSS3中规定的属性，它可以实现针对不同媒体设备来设置不同的样式的目的。而且就算是在同一设备中它也可以在你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。Bootstrap主要用到min-width、max-width，以及and语法，用于在不同的分辨率下设置不同的CSS样式。\n* 移动设备优先：在html文件中head区域加入这样的一个meta标签，name=“viewpoint”是指这个标签对移动设备生效，content中width=device-width是指宽度为设备宽度，initial-scale=1意思是初始缩放比例为1.\n* 栅格系统：将一个页面可以拆分成多个区块来理解，而正是这些区块共同构成了真个页面的布局。根据不同的屏幕尺寸情况，调整这些区块的排版，就可以实现响应式设计。另外，屏幕宽度较大的时候，区块倾向于水平分布，而屏幕宽度较小的时候，区块倾向于竖直堆叠。 栅格样式库一般是这样做的：将页面划分为若干等宽的列（column），然后推荐你通过等宽列来创建响应式的页面区块。 Bootstrap把它的栅格放在CSS这个分类下，并称它为Gird system。默认分为12列。\n![](/assets/images/2017/k3.jpg)\n\n---\n","mobiledoc":null,"html":"<h4 id=\"nodejs\">Node.js</h4>\n\n<ul>\n<li>并不是一门新的语言，与Java，PHP开发语言的平台也是不相同的，虽然他是JavaScript但是它并不是JavaScript的框架。</li>\n<li>nodejs是让JavaScript运行在服务器端的开发平台。当一种事务在一个领域独孤求败的时候就会想着进入另外一个领域，JavaScript已经在近几年已经一统的前端的江湖，所以已经开始进入服务端的领域。</li>\n<li>Node.js是基于Chrome JavaScript运行时建立的一个平台，使用C++编写的，实际上它是对Google Chrome V8引擎进行了封装，它主要用于创建快速的、可扩展的网络应用。</li>\n<li>Node.js采用事件驱动和非阻塞I/O模型，使其变得轻微和高效，非常适合构建运行在分布式设备的数据密集型实时应用。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"grunt\">Grunt</h4>\n\n<ul>\n<li>自动化。</li>\n<li>对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting等，自动化工具可以减轻你的劳动，简化你的工作。</li>\n<li>当你在 Gruntfile 文件正确配置好了任务，任务运行器就会自动帮你或你的小组完成大部分无聊的工作。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">模块化工具</h4>\n\n<ul>\n<li>requirejs、seajs</li>\n<li>将一些属性比较类似和行为比较类似的内容放在同一个js文件里面，把这个js文件称为模块，了每个js文件只关注与自身有关的事情，让每个js文件各行其职；</li>\n<li>MVC：veiw ( html + css + js )写静态页面 css、js、img及效果；controller ( 专注于实现服务和逻辑控制的层面叫做控制器 )监听页面中请求和事件，处理请求和事件；向model请求数据，得到数据后绑定到页面；model ( 数据变量 || ajax从服务端取回的数据 )对外提供一些数据</li>\n<li>命名冲突、文件依赖<img src=\"/assets/images/2017/k1.jpg\" alt=\"\" title=\"\" /><img src=\"/assets/images/2017/k2.jpg\" alt=\"\" title=\"\" /></li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">类库</h4>\n\n<ul>\n<li>解决的是代码或者是模块级别的复用或者对复杂度的封装问题，例如将一个解决复杂问题的功能模块封装成一个函数，提供一个简单的接口。</li>\n<li>它是一种工具，它提供了很多封装好的方法，用与不用取决于我们自身，即使用了也不会影响我们的代码结构。</li>\n</ul>\n\n<h4 id=\"\">框架</h4>\n\n<ul>\n<li>对模式级别的复用和对程序组织的规范。这里的模式是指比如MVC，为了实现M和V的解耦，把复杂的耦合关系由经常变化的业务代码转移到不经常变化的框架内部消化。</li>\n<li>是面向一个领域来提供一套解决方案，提高开发效率，如果我们选择了使用某框架，就应该遵循该框架所规定的规则。</li>\n</ul>\n\n<h4 id=\"\">区别是</h4>\n\n<ul>\n<li>JQuery以DOM操作为中心，框架，准确来说是MVC框架，是以模型（model）为中心，而DOM操作是附加的。所以，以模型为中心最终达到的目的是带来一整套工作流程的变更，使得后台工程师可以编写前端的模型代码，把后台与前端打通，交互设计师处理UI跟模型的互动关系，UI设计师可以专注、无障碍的处理HTML源码，把它们以界面模板的形式提交给交互工程师。这一整套协作机制能大大提高开发效率。使用MVC框架使得前端任务更好的被解耦。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"bootstrapui\">BootStrap：UI框架</h4>\n\n<ul>\n<li>响应式布局：响应式web布局是让用户通过不同尺寸的浏览器都可以获得良好视觉的一种方法。通过CSS3 Media Queries（媒体（设备）查询），媒体查询是让页面内容在不同的媒体环境下运行时可以展示不同的样式（这个样式当然是由我们来书写规定的）。@media是CSS3中规定的属性，它可以实现针对不同媒体设备来设置不同的样式的目的。而且就算是在同一设备中它也可以在你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。Bootstrap主要用到min-width、max-width，以及and语法，用于在不同的分辨率下设置不同的CSS样式。</li>\n<li>移动设备优先：在html文件中head区域加入这样的一个meta标签，name=“viewpoint”是指这个标签对移动设备生效，content中width=device-width是指宽度为设备宽度，initial-scale=1意思是初始缩放比例为1.</li>\n<li>栅格系统：将一个页面可以拆分成多个区块来理解，而正是这些区块共同构成了真个页面的布局。根据不同的屏幕尺寸情况，调整这些区块的排版，就可以实现响应式设计。另外，屏幕宽度较大的时候，区块倾向于水平分布，而屏幕宽度较小的时候，区块倾向于竖直堆叠。 栅格样式库一般是这样做的：将页面划分为若干等宽的列（column），然后推荐你通过等宽列来创建响应式的页面区块。 Bootstrap把它的栅格放在CSS这个分类下，并称它为Gird system。默认分为12列。\n<img src=\"/assets/images/2017/k3.jpg\" alt=\"\" /></li>\n</ul>\n\n<hr />","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-26 01:20:01","created_by":1,"updated_at":"2017-05-26 01:25:27","updated_by":1,"published_at":"2017-05-26 01:25:27","published_by":1},{"id":22,"uuid":"307c8840-5211-4ad1-bddc-3fe27174b5b3","title":"经典面试","slug":"jing-dian-mian-shi","markdown":"####RegExp\n* `var expression = /pattern /flags`\n* 特殊标志（flag）：g 全局模式；i 不区分大小写；m 多行模式；\n* 匹配模式（pattern） \n>![](/assets/images/2017/mian1.jpg)\n\n* 去掉空格、回车、制表符\n * `str.replace(/(^\\s*)|(\\s*$)/g, \"\")`：`(\\s*)`表示连续空格的字符串、`^`表示以开始、`$`表示以结尾；\n * 使用`jquery`的`$.trim()`方法\n\n---\n####JQuery\n* Ready\n* 插件\n\n---\n####跨域处理\n####HTTP请求、状态码\n####性能优化\n####JSON\n####兼容性问题\n\n---\n####图片延迟加载\n* 原理：页面可见区域以下的图片先不加载，等到用户向下滚动到图片位置时，再进行加载。\n* Js原生方法\n\n        <script>\n            var imgs = document.getElementsByTagName('img');\n            // 获取视口高度与滚动条的偏移量\n            function lazyload(){\n                var scrollTop = window.pageYOffset \n                    || document.documentElement.scrollTop \n                    || document.body.scrollTop;\n                var viewportSize = window.innerHeight \n                    || document.documentElement.clientHeight \n                    || document.body.clientHeight;\n                for(var i=0; i<imgs.length; i++) {\n                    var x =scrollTop+viewportSize-imgs[i].offsetTop;\n                    if(x>0){\n                        imgs[i].src = imgs[i].getAttribute('loadpic'); }}}\n                setInterval(lazyload,1000);\n        </script>\n* jQuery插件lazyload\n\n        $(\"img.lazy\").lazyload({\n            placeholder : \"img/grey.gif\", // placeholder值为某一图片路径.此图片用来占据将要加载的图片的位置,待图片加载时,占位图则会隐藏\n            effect: \"fadeIn\", // 载入使用何种效show(直接显示),fadeIn(淡入),slideDown(下拉)等,常用fadeIn\n            threshold: 200, // threshold,值为数字,代表页面高度.如设置为200,表示滚动条在离目标位置还有200的高度时就开始加载图片,可以做到不让用户察觉\n            event: 'click',  // 事件触发时才加载，值click(点击),mouseover(鼠标划过),sporty(运动的),foobar(…).可以实现鼠标莫过或点击图片才开始加载\n            container: $(\"#container\"),  // 对某容器中的图片实现效果,值为某容器.lazyload默认在拉动浏览器滚动条时生效,这个参数可以让你在拉动某DIV的滚动条时依次加载其中的图片\n            failurelimit : 10 //值为数字.lazyload默认在找到第一张不在可见区域里的图片时则不再继续加载,但当HTML容器混乱的时候可能出现可见区域内图片并没加载出来的情况,failurelimit意在加载N张可见区域外的图片,以避免出现这个问题.\n        });\n\n---\n####二维码扫描后跳转\n* 微信登录的二维码实际上是将一个URL转换成二维码的形式，而通过微信客户端扫码后，无非就是打开了这个url, 我捕捉到的微信二维码的url为`https://login.weixin.qq.com/l/YdmTu30I5A==` ，这个url里的`YdmTu30I5A==`代表的是本次会话的唯一ID, 这个有点儿类似浏览器里的session id，通过这个ID,微信就能定向将确认结果反馈到网页上。\n* 服务器收到了登录信息和sessionID后就可以确认两件事：一是用来确认登录的客户端的用户是验证过的；二是通过session ID服务器知道将反馈结果推送到哪个网页。\n* web实时推送技术，使用推送技术可以节约服务器端和客户端的资源，可以稳定地推送和接收任何消息。\n\n---\n####前端路由\n* 路由是根据不同的 url 地址展示不同的内容或页面，前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。\n* 优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户\n* 缺点：使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存；单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置。\n* 原理：当 url 的 hash 发生变化时，触发 hashchange 注册的回调，回调中去进行不同的操作，进行不同的内容的展示。\n* 后端路由：每跳转到不同的URL，都是重新访问服务端，然后服务端返回页面，页面也可以是服务端获取数据，然后和模板组合，返回HTML，也可以是直接返回模板HTML，然后由前端JS再去请求数据，使用前端模板和数据进行组合，生成想要的HTML。\n\n---\n####函数声明\n* var aaa=function(){...}：var 方式定义的函数，不能先调用函数，后声明，只能先声明函数，然后调用。\n* function aaa(){...}：function方式定义函数可以先调用，后声明。\n\n---\n####手写盒子模型中\n* 获取盒子内子节点的class样式，盒子内节点的类型不可知![](/assets/images/2017/mian2.jpg)\n\n---\n####JS底层实现原理\n* ECMAScript（核心）：JavaScript 语言基础；规定了 JavaScript 脚本的核心语法，如 数据类型、关键字、保留字、运算符、对象和语句等，它不属于任何浏览器。\n* DOM（文档对象模型）：规定了访问HTML和XML的接口；“ Document Object Model ”的缩写，简称“ 文件对象模型 ”，由W3C制定规范。定义了 JavaScript 操作 HTML 文档的接口，提供了访问 HTML 文档（如body、form、div、textarea等）的途径以及操作方法。\n* BOM（浏览器对象模型）：提供了独立于内容而在浏览器窗口之间进行交互的对象和方法。Browser Object Model ”的缩写，简称“ 浏览器对象模型 ”。BOM 定义了 JavaScript 操作浏览器的接口，提供了访问某些功能（如浏览器窗口大小、版本信息、浏览历史记录等）的途径以及操作方法。\n\n---\n","mobiledoc":null,"html":"<h4 id=\"regexp\">RegExp</h4>\n\n<ul>\n<li><code>var expression = /pattern /flags</code></li>\n<li>特殊标志（flag）：g 全局模式；i 不区分大小写；m 多行模式；</li>\n<li><p>匹配模式（pattern） </p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/mian1.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote></li>\n<li><p>去掉空格、回车、制表符</p>\n\n<ul><li><code>str.replace(/(^\\s*)|(\\s*$)/g, \"\")</code>：<code>(\\s*)</code>表示连续空格的字符串、<code>^</code>表示以开始、<code>$</code>表示以结尾；</li>\n<li>使用<code>jquery</code>的<code>$.trim()</code>方法</li></ul></li>\n</ul>\n\n<hr />\n\n<h4 id=\"jquery\">JQuery</h4>\n\n<ul>\n<li>Ready</li>\n<li>插件</li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">跨域处理</h4>\n\n<h4 id=\"http\">HTTP请求、状态码</h4>\n\n<h4 id=\"\">性能优化</h4>\n\n<h4 id=\"json\">JSON</h4>\n\n<h4 id=\"\">兼容性问题</h4>\n\n<hr />\n\n<h4 id=\"\">图片延迟加载</h4>\n\n<ul>\n<li>原理：页面可见区域以下的图片先不加载，等到用户向下滚动到图片位置时，再进行加载。</li>\n<li><p>Js原生方法</p>\n\n<pre><code>&lt;script&gt;\n    var imgs = document.getElementsByTagName('img');\n    // 获取视口高度与滚动条的偏移量\n    function lazyload(){\n        var scrollTop = window.pageYOffset \n            || document.documentElement.scrollTop \n            || document.body.scrollTop;\n        var viewportSize = window.innerHeight \n            || document.documentElement.clientHeight \n            || document.body.clientHeight;\n        for(var i=0; i&lt;imgs.length; i++) {\n            var x =scrollTop+viewportSize-imgs[i].offsetTop;\n            if(x&gt;0){\n                imgs[i].src = imgs[i].getAttribute('loadpic'); }}}\n        setInterval(lazyload,1000);\n&lt;/script&gt;\n</code></pre></li>\n<li><p>jQuery插件lazyload</p>\n\n<pre><code>$(\"img.lazy\").lazyload({\n    placeholder : \"img/grey.gif\", // placeholder值为某一图片路径.此图片用来占据将要加载的图片的位置,待图片加载时,占位图则会隐藏\n    effect: \"fadeIn\", // 载入使用何种效show(直接显示),fadeIn(淡入),slideDown(下拉)等,常用fadeIn\n    threshold: 200, // threshold,值为数字,代表页面高度.如设置为200,表示滚动条在离目标位置还有200的高度时就开始加载图片,可以做到不让用户察觉\n    event: 'click',  // 事件触发时才加载，值click(点击),mouseover(鼠标划过),sporty(运动的),foobar(…).可以实现鼠标莫过或点击图片才开始加载\n    container: $(\"#container\"),  // 对某容器中的图片实现效果,值为某容器.lazyload默认在拉动浏览器滚动条时生效,这个参数可以让你在拉动某DIV的滚动条时依次加载其中的图片\n    failurelimit : 10 //值为数字.lazyload默认在找到第一张不在可见区域里的图片时则不再继续加载,但当HTML容器混乱的时候可能出现可见区域内图片并没加载出来的情况,failurelimit意在加载N张可见区域外的图片,以避免出现这个问题.\n});\n</code></pre></li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">二维码扫描后跳转</h4>\n\n<ul>\n<li>微信登录的二维码实际上是将一个URL转换成二维码的形式，而通过微信客户端扫码后，无非就是打开了这个url, 我捕捉到的微信二维码的url为<code>https://login.weixin.qq.com/l/YdmTu30I5A==</code> ，这个url里的<code>YdmTu30I5A==</code>代表的是本次会话的唯一ID, 这个有点儿类似浏览器里的session id，通过这个ID,微信就能定向将确认结果反馈到网页上。</li>\n<li>服务器收到了登录信息和sessionID后就可以确认两件事：一是用来确认登录的客户端的用户是验证过的；二是通过session ID服务器知道将反馈结果推送到哪个网页。</li>\n<li>web实时推送技术，使用推送技术可以节约服务器端和客户端的资源，可以稳定地推送和接收任何消息。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">前端路由</h4>\n\n<ul>\n<li>路由是根据不同的 url 地址展示不同的内容或页面，前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。</li>\n<li>优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户</li>\n<li>缺点：使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存；单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置。</li>\n<li>原理：当 url 的 hash 发生变化时，触发 hashchange 注册的回调，回调中去进行不同的操作，进行不同的内容的展示。</li>\n<li>后端路由：每跳转到不同的URL，都是重新访问服务端，然后服务端返回页面，页面也可以是服务端获取数据，然后和模板组合，返回HTML，也可以是直接返回模板HTML，然后由前端JS再去请求数据，使用前端模板和数据进行组合，生成想要的HTML。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">函数声明</h4>\n\n<ul>\n<li>var aaa=function(){...}：var 方式定义的函数，不能先调用函数，后声明，只能先声明函数，然后调用。</li>\n<li>function aaa(){...}：function方式定义函数可以先调用，后声明。</li>\n</ul>\n\n<hr />\n\n<h4 id=\"\">手写盒子模型中</h4>\n\n<ul>\n<li>获取盒子内子节点的class样式，盒子内节点的类型不可知<img src=\"/assets/images/2017/mian2.jpg\" alt=\"\" title=\"\" /></li>\n</ul>\n\n<hr />\n\n<h4 id=\"js\">JS底层实现原理</h4>\n\n<ul>\n<li>ECMAScript（核心）：JavaScript 语言基础；规定了 JavaScript 脚本的核心语法，如 数据类型、关键字、保留字、运算符、对象和语句等，它不属于任何浏览器。</li>\n<li>DOM（文档对象模型）：规定了访问HTML和XML的接口；“ Document Object Model ”的缩写，简称“ 文件对象模型 ”，由W3C制定规范。定义了 JavaScript 操作 HTML 文档的接口，提供了访问 HTML 文档（如body、form、div、textarea等）的途径以及操作方法。</li>\n<li>BOM（浏览器对象模型）：提供了独立于内容而在浏览器窗口之间进行交互的对象和方法。Browser Object Model ”的缩写，简称“ 浏览器对象模型 ”。BOM 定义了 JavaScript 操作浏览器的接口，提供了访问某些功能（如浏览器窗口大小、版本信息、浏览历史记录等）的途径以及操作方法。</li>\n</ul>\n\n<hr />","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-26 01:26:42","created_by":1,"updated_at":"2017-05-26 01:37:46","updated_by":1,"published_at":"2017-05-26 01:37:46","published_by":1},{"id":23,"uuid":"c9f4d983-653c-45d7-81a2-6d61d0a56d10","title":"ES6新特性","slug":"es6xin-te-xing","markdown":"####ECMAScript 2015（ES6）的十大特征\n* 默认参数：`var link = function(height = 50, color = 'red', url = 'http://azat.co') {...}`\n* 模板对象：`var name = 'Your name is ${first} ${last}.' `; 反引号\n* 多行字符串：反引号\n* 解构赋值：自动解析数组或对象中的值，不用以对象的方式返回。\n* 增强的对象字面量：实现继承，可以直接在对象字面量里面定义原型，不用再用function 关键字。\n> ![](/assets/images/2017/es1.jpg)\n\n* 箭头函数：箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定，完全修复了this的指向，this总是指向词法作用域。\n\n---\n* Promises\n> ![](/assets/images/2017/es2.jpg)\n\n * 异步方法调用中，往往会出现回调函数一环扣一环的情况。这种情况导致了回调金字塔问题的出现。不仅代码写起来费劲又不美观，而且问题复杂的时候，阅读代码的人也难以理解。\n * 三种状态：Fulfilled成功、Rejected失败、Pending为 Promise 对象实例创建时候的初始状态，待执行；\n>![](/assets/images/2017/es3.jpg)\n\n * ajax操作Promise化，可以实现链式使用。避免了传统的只能使用回调的麻烦。\n * Promise实现异步任务顺序执行\n * Promise实现异步任务并行执行\n * 顺序执行效率低，并行执行但是需要所有的数据加载完成才能开始渲染，并行加载顺序渲染。\n> ![](/assets/images/2017/es4.jpg)\n> ![](/assets/images/2017/es5.jpg)\n \n * 第一步，加载了story.json的数据；第二步，把数据转换成JSON格式；第三步，把JSON数据打印出来。\n> ![](/assets/images/2017/es6.jpg)\n> ![](/assets/images/2017/es7.jpg)\n> ![](/assets/images/2017/es8.jpg)\n \n---\n* 块级作用域\n * let声明的变量只在块级有效。let没有‘变量提升’的特性，而却有‘暂时性死区（temporal dead zone）’的特性。\n * const命令与let命令一样，声明的变量，其作用域都是块级。所以const遵循的规则与let相差无二，只是，const是用来声明恒定变量的。且用const声明恒定变量，声明的同时就必须赋值，否则会报错。\n* 类\n * 类的所有实例共享一个原型对象。\n * 不存在变量提升\n * 私有方法添加下划线\n * 类的方法内部如果含有this，它默认指向类的实例\n * 继承extends，子类必须在constructor方法中调用super方法，否则新建实例时会报错。\n* 模块\n * JS是解释型语言，边加载边运行，后续脚本运行时，这些脚本所依赖的一切必须已经加载完毕；JS脚本加载时会阻塞浏览器，如果加载的JS很多很大，浏览器会卡住，带来很差的用户体验；通过调整script标签顺序可以修改JS模块之间的依赖，然而当模块很多时，这种做法就不可用了。\n * AMD模块（RequireJS）、CommonJS模块（Node.js）、CMD(SeaJS)\n * 导出export\n * 导入import\n\n---\n","mobiledoc":null,"html":"<h4 id=\"ecmascript2015es6\">ECMAScript 2015（ES6）的十大特征</h4>\n\n<ul>\n<li>默认参数：<code>var link = function(height = 50, color = 'red', url = 'http://azat.co') {...}</code></li>\n<li>模板对象：<code>var name = 'Your name is ${first} ${last}.'</code>; 反引号</li>\n<li>多行字符串：反引号</li>\n<li>解构赋值：自动解析数组或对象中的值，不用以对象的方式返回。</li>\n<li><p>增强的对象字面量：实现继承，可以直接在对象字面量里面定义原型，不用再用function 关键字。</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/es1.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote></li>\n<li><p>箭头函数：箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定，完全修复了this的指向，this总是指向词法作用域。</p></li>\n</ul>\n\n<hr />\n\n<ul>\n<li><p>Promises</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/es2.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote>\n\n<ul><li>异步方法调用中，往往会出现回调函数一环扣一环的情况。这种情况导致了回调金字塔问题的出现。不仅代码写起来费劲又不美观，而且问题复杂的时候，阅读代码的人也难以理解。</li>\n<li><p>三种状态：Fulfilled成功、Rejected失败、Pending为 Promise 对象实例创建时候的初始状态，待执行；</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/es3.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote></li>\n<li><p>ajax操作Promise化，可以实现链式使用。避免了传统的只能使用回调的麻烦。</p></li>\n<li>Promise实现异步任务顺序执行</li>\n<li>Promise实现异步任务并行执行</li>\n<li><p>顺序执行效率低，并行执行但是需要所有的数据加载完成才能开始渲染，并行加载顺序渲染。</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/es4.jpg\" alt=\"\" title=\"\" />\n  <img src=\"/assets/images/2017/es5.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote></li>\n<li><p>第一步，加载了story.json的数据；第二步，把数据转换成JSON格式；第三步，把JSON数据打印出来。</p>\n\n<blockquote>\n  <p><img src=\"/assets/images/2017/es6.jpg\" alt=\"\" title=\"\" />\n  <img src=\"/assets/images/2017/es7.jpg\" alt=\"\" title=\"\" />\n  <img src=\"/assets/images/2017/es8.jpg\" alt=\"\" title=\"\" /></p>\n</blockquote></li></ul></li>\n</ul>\n\n<hr />\n\n<ul>\n<li>块级作用域\n<ul><li>let声明的变量只在块级有效。let没有‘变量提升’的特性，而却有‘暂时性死区（temporal dead zone）’的特性。</li>\n<li>const命令与let命令一样，声明的变量，其作用域都是块级。所以const遵循的规则与let相差无二，只是，const是用来声明恒定变量的。且用const声明恒定变量，声明的同时就必须赋值，否则会报错。</li></ul></li>\n<li>类\n<ul><li>类的所有实例共享一个原型对象。</li>\n<li>不存在变量提升</li>\n<li>私有方法添加下划线</li>\n<li>类的方法内部如果含有this，它默认指向类的实例</li>\n<li>继承extends，子类必须在constructor方法中调用super方法，否则新建实例时会报错。</li></ul></li>\n<li>模块\n<ul><li>JS是解释型语言，边加载边运行，后续脚本运行时，这些脚本所依赖的一切必须已经加载完毕；JS脚本加载时会阻塞浏览器，如果加载的JS很多很大，浏览器会卡住，带来很差的用户体验；通过调整script标签顺序可以修改JS模块之间的依赖，然而当模块很多时，这种做法就不可用了。</li>\n<li>AMD模块（RequireJS）、CommonJS模块（Node.js）、CMD(SeaJS)</li>\n<li>导出export</li>\n<li>导入import</li></ul></li>\n</ul>\n\n<hr />","amp":null,"image":null,"featured":0,"page":0,"status":"published","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2017-05-26 01:45:04","created_by":1,"updated_at":"2017-05-26 01:56:54","updated_by":1,"published_at":"2017-05-26 01:56:54","published_by":1}],"users":[{"id":1,"uuid":"f217cf7c-1fc1-497f-beaa-1a6f48802a9f","name":"Jing HU","slug":"jing","password":"$2a$10$1Ryx32ZyniJcJ0kINjlbO.j0rYSZDIil2yOA013Hjs6yXChpGhOHa","email":"hujingdada@126.com","image":"/assets/images/2017/--_---.jpg","cover":null,"bio":null,"website":null,"location":null,"facebook":null,"twitter":null,"accessibility":null,"status":"active","language":"en_US","visibility":"public","meta_title":null,"meta_description":null,"tour":null,"last_login":"2018-03-23 01:05:15","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2018-03-23 01:05:15","updated_by":1}],"roles":[{"id":1,"uuid":"dadfee71-390b-4d89-810a-09d79258d66c","name":"Administrator","description":"Administrators","created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":2,"uuid":"c301f9ad-7060-4f39-b4b2-b5076154612a","name":"Editor","description":"Editors","created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":3,"uuid":"8da18b7d-d0c0-4a3a-b5e7-8b2b67dab36c","name":"Author","description":"Authors","created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":4,"uuid":"475ffe6e-4336-492a-a410-554ea2806992","name":"Owner","description":"Blog Owner","created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1}],"roles_users":[{"id":1,"role_id":4,"user_id":1}],"permissions":[{"id":1,"uuid":"4f727e78-c14c-4759-abcd-91022985ef45","name":"Export database","object_type":"db","action_type":"exportContent","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":2,"uuid":"e3d6488c-2323-481a-a986-8c9c74eca49c","name":"Import database","object_type":"db","action_type":"importContent","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":3,"uuid":"703f12c7-3858-4e9b-a741-da717db28c21","name":"Delete all content","object_type":"db","action_type":"deleteAllContent","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":4,"uuid":"6dee923e-9834-419a-8154-3eac019ec87e","name":"Send mail","object_type":"mail","action_type":"send","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":5,"uuid":"82e3f2cc-c689-436a-9cf4-449157117f5e","name":"Browse notifications","object_type":"notification","action_type":"browse","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":6,"uuid":"ea3d9669-fadd-483a-8cde-1ad60331fd5f","name":"Add notifications","object_type":"notification","action_type":"add","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":7,"uuid":"e4c2b91a-5435-4db6-9b6a-9a7938c4f0a0","name":"Delete notifications","object_type":"notification","action_type":"destroy","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":8,"uuid":"82620d58-efba-4099-a378-ff60d0136644","name":"Browse posts","object_type":"post","action_type":"browse","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":9,"uuid":"7eac95ed-e31a-49f8-a04a-e3b1c783c23d","name":"Read posts","object_type":"post","action_type":"read","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":10,"uuid":"b8b68422-a911-4473-9abb-a08c4bbc9143","name":"Edit posts","object_type":"post","action_type":"edit","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":11,"uuid":"5ef11798-8ed6-48ff-b00e-426fc76143ac","name":"Add posts","object_type":"post","action_type":"add","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":12,"uuid":"690e037f-5084-409f-be28-c5ea4f1e111e","name":"Delete posts","object_type":"post","action_type":"destroy","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":13,"uuid":"c09b4763-69a3-41d2-8da7-33cf2d62d29b","name":"Browse settings","object_type":"setting","action_type":"browse","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":14,"uuid":"df10c2ec-9e44-405d-8ce0-410cd13b5221","name":"Read settings","object_type":"setting","action_type":"read","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":15,"uuid":"b0e3fad5-ceba-4914-a7a4-5af33e09fada","name":"Edit settings","object_type":"setting","action_type":"edit","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":16,"uuid":"69560f1d-dab5-4f5d-ba55-e2e322451915","name":"Generate slugs","object_type":"slug","action_type":"generate","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":17,"uuid":"6b5b682c-1a36-4a89-abaf-24840f4cfe7a","name":"Browse tags","object_type":"tag","action_type":"browse","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":18,"uuid":"2b8ef7cc-3878-4517-a438-e56f50797512","name":"Read tags","object_type":"tag","action_type":"read","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":19,"uuid":"3d1caf9a-09e3-4025-a842-b2d8c63804ca","name":"Edit tags","object_type":"tag","action_type":"edit","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":20,"uuid":"fab41f3b-c036-4ed9-a50b-d02c511bf1c7","name":"Add tags","object_type":"tag","action_type":"add","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":21,"uuid":"478f8ba1-178d-4501-81c0-6fa147235d5a","name":"Delete tags","object_type":"tag","action_type":"destroy","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":22,"uuid":"a7746e05-b4ca-4337-b8bc-d079d3bf3dc0","name":"Browse themes","object_type":"theme","action_type":"browse","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":23,"uuid":"a5f39f87-4ce1-46b6-bd93-76364738aa64","name":"Edit themes","object_type":"theme","action_type":"edit","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":24,"uuid":"3b6219e5-5d65-4947-bc85-213ccd08dfee","name":"Upload themes","object_type":"theme","action_type":"add","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":25,"uuid":"c45ef0bd-4c61-49ec-bcb7-5005d290308d","name":"Download themes","object_type":"theme","action_type":"read","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":26,"uuid":"75b8240e-3fd1-44de-976c-bffd6a62709f","name":"Delete themes","object_type":"theme","action_type":"destroy","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":27,"uuid":"df5b39ac-d812-4a54-a51a-0e096a1f36ed","name":"Browse users","object_type":"user","action_type":"browse","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":28,"uuid":"4fd9c3c7-4546-4cf5-be01-5e64414d4c89","name":"Read users","object_type":"user","action_type":"read","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":29,"uuid":"5e5889a9-40e3-4667-b0af-84d1773f38e6","name":"Edit users","object_type":"user","action_type":"edit","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":30,"uuid":"42b51ccb-977e-45f0-beb9-4c794cbae4df","name":"Add users","object_type":"user","action_type":"add","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":31,"uuid":"456cb354-5d69-45a9-8dad-6268c559856b","name":"Delete users","object_type":"user","action_type":"destroy","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":32,"uuid":"4bde95cc-6167-4a51-8835-3e9987368392","name":"Assign a role","object_type":"role","action_type":"assign","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":33,"uuid":"1b201889-5b41-47a4-b8b8-99f8f1880696","name":"Browse roles","object_type":"role","action_type":"browse","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":34,"uuid":"b6768337-f2a0-459a-8b91-a2607c4b9f7d","name":"Browse clients","object_type":"client","action_type":"browse","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":35,"uuid":"699ff55b-1e5b-420d-a625-7502b639adfd","name":"Read clients","object_type":"client","action_type":"read","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":36,"uuid":"53827830-0ac0-42f0-8363-aacfbf2412eb","name":"Edit clients","object_type":"client","action_type":"edit","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":37,"uuid":"4f45e972-fdad-46e2-b8ce-8c7a172897dc","name":"Add clients","object_type":"client","action_type":"add","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":38,"uuid":"bb68906f-8088-4e6d-8004-a7bf5e1b0aaf","name":"Delete clients","object_type":"client","action_type":"destroy","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":39,"uuid":"a1ab8c31-584b-47aa-a9dd-894ce8c7e7ce","name":"Browse subscribers","object_type":"subscriber","action_type":"browse","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":40,"uuid":"d948b344-7914-45a1-966d-4035568c0d2b","name":"Read subscribers","object_type":"subscriber","action_type":"read","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":41,"uuid":"4ed927f3-7a37-42ee-a39e-d99f7512a9c3","name":"Edit subscribers","object_type":"subscriber","action_type":"edit","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":42,"uuid":"f49df26e-bf77-4345-b523-34024fea55c1","name":"Add subscribers","object_type":"subscriber","action_type":"add","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1},{"id":43,"uuid":"b02ea2bc-0582-4074-80b5-7fd0c1bfa821","name":"Delete subscribers","object_type":"subscriber","action_type":"destroy","object_id":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1}],"permissions_users":[],"permissions_roles":[{"id":1,"role_id":1,"permission_id":1},{"id":2,"role_id":1,"permission_id":2},{"id":3,"role_id":1,"permission_id":3},{"id":4,"role_id":1,"permission_id":4},{"id":5,"role_id":1,"permission_id":5},{"id":6,"role_id":1,"permission_id":6},{"id":7,"role_id":1,"permission_id":7},{"id":8,"role_id":1,"permission_id":8},{"id":9,"role_id":1,"permission_id":10},{"id":10,"role_id":1,"permission_id":9},{"id":11,"role_id":1,"permission_id":11},{"id":12,"role_id":1,"permission_id":12},{"id":13,"role_id":1,"permission_id":14},{"id":14,"role_id":1,"permission_id":13},{"id":15,"role_id":1,"permission_id":15},{"id":16,"role_id":1,"permission_id":16},{"id":17,"role_id":1,"permission_id":17},{"id":18,"role_id":1,"permission_id":19},{"id":19,"role_id":1,"permission_id":18},{"id":20,"role_id":1,"permission_id":20},{"id":21,"role_id":1,"permission_id":21},{"id":22,"role_id":1,"permission_id":22},{"id":23,"role_id":1,"permission_id":23},{"id":24,"role_id":1,"permission_id":24},{"id":25,"role_id":1,"permission_id":25},{"id":26,"role_id":1,"permission_id":26},{"id":27,"role_id":1,"permission_id":27},{"id":28,"role_id":1,"permission_id":28},{"id":29,"role_id":1,"permission_id":29},{"id":30,"role_id":1,"permission_id":31},{"id":31,"role_id":1,"permission_id":30},{"id":32,"role_id":1,"permission_id":32},{"id":33,"role_id":1,"permission_id":33},{"id":34,"role_id":1,"permission_id":34},{"id":35,"role_id":1,"permission_id":35},{"id":36,"role_id":1,"permission_id":38},{"id":37,"role_id":1,"permission_id":36},{"id":38,"role_id":1,"permission_id":37},{"id":39,"role_id":1,"permission_id":41},{"id":40,"role_id":1,"permission_id":39},{"id":41,"role_id":1,"permission_id":40},{"id":42,"role_id":1,"permission_id":42},{"id":43,"role_id":1,"permission_id":43},{"id":44,"role_id":2,"permission_id":8},{"id":45,"role_id":2,"permission_id":11},{"id":46,"role_id":2,"permission_id":10},{"id":47,"role_id":2,"permission_id":9},{"id":48,"role_id":2,"permission_id":12},{"id":49,"role_id":2,"permission_id":13},{"id":50,"role_id":2,"permission_id":14},{"id":51,"role_id":2,"permission_id":16},{"id":52,"role_id":2,"permission_id":18},{"id":53,"role_id":2,"permission_id":19},{"id":54,"role_id":2,"permission_id":20},{"id":55,"role_id":2,"permission_id":17},{"id":56,"role_id":2,"permission_id":21},{"id":57,"role_id":2,"permission_id":27},{"id":58,"role_id":2,"permission_id":28},{"id":59,"role_id":2,"permission_id":30},{"id":60,"role_id":2,"permission_id":31},{"id":61,"role_id":2,"permission_id":29},{"id":62,"role_id":2,"permission_id":32},{"id":63,"role_id":2,"permission_id":33},{"id":64,"role_id":2,"permission_id":34},{"id":65,"role_id":2,"permission_id":36},{"id":66,"role_id":2,"permission_id":37},{"id":67,"role_id":2,"permission_id":35},{"id":68,"role_id":2,"permission_id":38},{"id":69,"role_id":2,"permission_id":42},{"id":70,"role_id":3,"permission_id":8},{"id":71,"role_id":3,"permission_id":11},{"id":72,"role_id":3,"permission_id":9},{"id":73,"role_id":3,"permission_id":13},{"id":74,"role_id":3,"permission_id":14},{"id":75,"role_id":3,"permission_id":16},{"id":76,"role_id":3,"permission_id":17},{"id":77,"role_id":3,"permission_id":20},{"id":78,"role_id":3,"permission_id":18},{"id":79,"role_id":3,"permission_id":27},{"id":80,"role_id":3,"permission_id":28},{"id":81,"role_id":3,"permission_id":33},{"id":82,"role_id":3,"permission_id":34},{"id":83,"role_id":3,"permission_id":35},{"id":84,"role_id":3,"permission_id":36},{"id":85,"role_id":3,"permission_id":37},{"id":86,"role_id":3,"permission_id":38},{"id":87,"role_id":3,"permission_id":42}],"permissions_apps":[],"settings":[{"id":1,"uuid":"2f8b5185-9378-444d-8a16-83838984f334","key":"databaseVersion","value":"009","type":"core","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-05-18 01:49:50","updated_by":1},{"id":2,"uuid":"494f7130-7db7-4507-a5fa-d32682e6c233","key":"displayUpdateNotification","value":"0.11.12","type":"core","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2018-03-23 01:05:09","updated_by":1},{"id":3,"uuid":"4770dad9-3460-4ddb-8b2c-01450e4b71f1","key":"seenNotifications","value":"[]","type":"core","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-05-18 01:49:50","updated_by":1},{"id":4,"uuid":"75bbf569-2a13-4248-a008-6cc3d37250f1","key":"migrations","value":"{}","type":"core","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-05-18 01:49:50","updated_by":1},{"id":5,"uuid":"59aa36c7-222a-455e-ab84-f6573d57f5b0","key":"title","value":"Smiling Dada","type":"blog","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":6,"uuid":"62e5d36b-bd7c-42c3-9eb8-8b33f0c2092c","key":"description","value":"Thoughts, stories and ideas.","type":"blog","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":7,"uuid":"87fa5ad8-2ebc-491c-9f05-be3772fd0af3","key":"logo","value":"","type":"blog","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":8,"uuid":"2c737ae7-5834-4fcc-a86b-a9833461cede","key":"cover","value":"","type":"blog","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":9,"uuid":"42a15463-b095-455c-a21a-5d72ca842be4","key":"defaultLang","value":"en_US","type":"blog","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":10,"uuid":"2ca71dcd-643a-40a4-ba44-cad4aec9dab7","key":"postsPerPage","value":"5","type":"blog","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":11,"uuid":"ff86ee92-62e4-4ccc-b8af-f8a6206ae5f1","key":"activeTimezone","value":"Etc/UTC","type":"blog","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":12,"uuid":"88c65a0c-60cb-4b7f-8159-e15169dbfcb4","key":"forceI18n","value":"true","type":"blog","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":13,"uuid":"a7e9d31b-1987-4132-a771-33947d205ca8","key":"permalinks","value":"/:slug/","type":"blog","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":14,"uuid":"0e9751d8-d51b-46ff-9e4b-5149bf1e7c92","key":"amp","value":"true","type":"blog","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":15,"uuid":"4c752561-5504-4ea8-a1d9-d73cfdc01768","key":"ghost_head","value":"","type":"blog","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":16,"uuid":"3928919c-9615-4072-a44e-89a56e9ed8d1","key":"ghost_foot","value":"","type":"blog","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":17,"uuid":"7fd99f7d-c279-4e69-b8c4-5324442bb014","key":"facebook","value":"","type":"blog","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":18,"uuid":"eec9d73a-3833-48c9-bdef-facabeb53d0b","key":"twitter","value":"","type":"blog","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":19,"uuid":"78b3050e-9101-424d-aef6-414d7c04043a","key":"labs","value":"{}","type":"blog","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":20,"uuid":"f1fea414-dacd-4667-8dae-44d1a7df2ba8","key":"navigation","value":"[{\"label\":\"Home\",\"url\":\"http://hujingdada.top\"},{\"label\":\"CSS-基础\",\"url\":\"http://hujingdada.top/css-ji-chu/\"},{\"label\":\"CSS--Float\",\"url\":\"http://hujingdada.top/css-floatfu-dong/\"},{\"label\":\"CSS--Layout\",\"url\":\"http://hujingdada.top/css-layout/\"},{\"label\":\"CSS--BFC\",\"url\":\"http://hujingdada.top/css-bfc/\"},{\"label\":\"CSS--Animation\",\"url\":\"http://hujingdada.top/css-draw/\"},{\"label\":\"CSS--Draw\",\"url\":\"http://hujingdada.top/css-animation/\"},{\"label\":\"JS--数据类型\",\"url\":\"http://hujingdada.top/js-shu-ju-lei-xing/\"},{\"label\":\"JS--面向对象\",\"url\":\"http://hujingdada.top/js-mian-xiang-dui-xiang/\"},{\"label\":\"JS--AJAX\",\"url\":\"http://hujingdada.top/js-ajax/\"},{\"label\":\"JS--JSON\",\"url\":\"http://hujingdada.top/js-json/\"},{\"label\":\"JS--DOM&Event\",\"url\":\"http://hujingdada.top/js_dom-event/\"},{\"label\":\"JS--BOM\",\"url\":\"http://hujingdada.top/js_bom/\"},{\"label\":\"HTTP--基础\",\"url\":\"http://hujingdada.top/http/\"},{\"label\":\"HTTP状态码\",\"url\":\"http://hujingdada.top/httpzhuang-tai-ma/\"},{\"label\":\"HTML--基础\",\"url\":\"http://hujingdada.top/html/\"},{\"label\":\"前端性能\",\"url\":\"http://hujingdada.top/qian-duan-xing-neng/\"},{\"label\":\"前后端联合开发\",\"url\":\"http://hujingdada.top/qian-hou-duan-lian-he-kai-fa/\"},{\"label\":\"前端开发模式\",\"url\":\"http://hujingdada.top/qian-duan-kai-fa-mo-shi/\"},{\"label\":\"浏览器渲染及加载\",\"url\":\"http://hujingdada.top/liu-lan-qi-xuan-ran-ji-jia-zai/\"},{\"label\":\"前端框架\",\"url\":\"http://hujingdada.top/qian-duan-kuang-jia/\"},{\"label\":\"经典面试\",\"url\":\"http://hujingdada.top/jing-dian-mian-shi/\"},{\"label\":\"ES6新特性\",\"url\":\"http://hujingdada.top/es6xin-te-xing/\"}]","type":"blog","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":21,"uuid":"9e56543c-d288-4c48-ab3f-0a8077603c1d","key":"slack","value":"[{\"url\":\"\"}]","type":"blog","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":22,"uuid":"8fdf71b0-09f7-4b17-88e1-0839a312a512","key":"activeApps","value":"[]","type":"app","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-05-18 01:49:50","updated_by":1},{"id":23,"uuid":"492e9f76-9302-4714-a3ec-14f5d96d4fdb","key":"installedApps","value":"[]","type":"app","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2018-03-23 01:04:42","updated_by":1},{"id":24,"uuid":"b568a2a6-95f5-4978-a830-4be2b6626658","key":"password","value":"","type":"private","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":25,"uuid":"3bb21602-eae4-4bd4-964a-c69e2606107f","key":"dbHash","value":"a64e66f4-08d6-4d21-ac4d-b533e48d1313","type":"core","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-05-18 01:49:50","updated_by":1},{"id":26,"uuid":"1cd02481-64f4-4c81-95e7-b7f1760e7e5b","key":"nextUpdateCheck","value":"1521853518","type":"core","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2018-03-23 01:05:09","updated_by":1},{"id":27,"uuid":"c12268b7-a47a-4686-b1f0-3ccf5610b722","key":"isPrivate","value":"false","type":"private","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1},{"id":28,"uuid":"e72f72c0-0052-4d92-ba8c-e66bb5e3d4de","key":"activeTheme","value":"casper","type":"theme","created_at":"2017-05-18 01:49:50","created_by":1,"updated_at":"2017-06-01 11:36:30","updated_by":1}],"tags":[{"id":1,"uuid":"a0486935-e482-4eb4-917d-9fb88c4d20f7","name":"Getting Started","slug":"getting-started","description":null,"image":null,"parent_id":null,"visibility":"public","meta_title":null,"meta_description":null,"created_at":"2017-05-18 01:49:49","created_by":1,"updated_at":"2017-05-18 01:49:49","updated_by":1}],"posts_tags":[{"id":1,"post_id":1,"tag_id":1,"sort_order":0}],"apps":[],"app_settings":[],"app_fields":[],"subscribers":[]}}]}