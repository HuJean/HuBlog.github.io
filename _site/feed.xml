<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2018-03-29T14:18:08+08:00</updated><id>http://localhost:4000/</id><title type="html">胡静</title><subtitle>Talk less and code more.</subtitle><author><name>Dada</name><email>hujingdada@126.com</email></author><entry><title type="html">前端学习笔记</title><link href="http://localhost:4000/blog/2018/03/28/GraphQL/" rel="alternate" type="text/html" title="前端学习笔记" /><published>2018-03-28T08:00:00+08:00</published><updated>2018-03-28T08:00:00+08:00</updated><id>http://localhost:4000/blog/2018/03/28/GraphQL</id><content type="html" xml:base="http://localhost:4000/blog/2018/03/28/GraphQL/">&lt;p&gt;GraphQL是一个用于API的查询语言，是一个使用基于类型系统来执行查询的服务端运行时（类型系统由你的数据定义）。
GraphQL并没有和任何特定数据库或者存储引擎绑定，而是依靠你现有的代码和数据支撑。&lt;/p&gt;

&lt;p&gt;Google Analytics(GA)可以监控网站十分之多的数据，是每个网站必备的分析工具。&lt;/p&gt;</content><author><name>Dada</name><email>hujingdada@126.com</email></author><category term="GraphQL" /><category term="Google Analytics" /><summary type="html">GraphQL是一个用于API的查询语言，是一个使用基于类型系统来执行查询的服务端运行时（类型系统由你的数据定义）。 GraphQL并没有和任何特定数据库或者存储引擎绑定，而是依靠你现有的代码和数据支撑。</summary></entry><entry><title type="html">Babel学习笔记</title><link href="http://localhost:4000/blog/2018/03/28/Babel/" rel="alternate" type="text/html" title="Babel学习笔记" /><published>2018-03-28T07:00:00+08:00</published><updated>2018-03-28T07:00:00+08:00</updated><id>http://localhost:4000/blog/2018/03/28/Babel</id><content type="html" xml:base="http://localhost:4000/blog/2018/03/28/Babel/">&lt;p&gt;Babel的功能非常纯粹，以字符串的形式将源代码传给它，它就会返回一段新的代码字符串，既不会运行你的代码，也不会将多个代码打包到一起，只是个编译器，输入语言是ES6+，编译目标语言是ES5。&lt;/p&gt;

&lt;h1 id=&quot;heading-基本使用&quot;&gt;基本使用&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;安装插件：&lt;/li&gt;
  &lt;li&gt;配置文件：.babelrc
    &lt;ul&gt;
      &lt;li&gt;plugins：插件&lt;/li&gt;
      &lt;li&gt;presets字段设定转码规则&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ES2015转码规则
  $ npm install --save-dev babel-preset-es2015
  react转码规则
  $ npm install --save-dev babel-preset-react
  ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个
  $ npm install --save-dev babel-preset-stage-0
  $ npm install --save-dev babel-preset-stage-1
  $ npm install --save-dev babel-preset-stage-2
  $ npm install --save-dev babel-preset-stage-3
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;工具
    &lt;ul&gt;
      &lt;li&gt;babel-cli：命令行转码&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  安装
  $ npm install --save-dev babel-cli
  package.json
  // ...
  &quot;devDependencies&quot;: {
    &quot;babel-cli&quot;: &quot;^6.0.0&quot;
  },
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;babel src -d lib&quot;
  }
  运行
  $ npm run build
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;babel-register：模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  安装
  $ npm install --save-dev babel-register
  运行前
  require(&quot;babel-register&quot;);
  require(&quot;./index.js&quot;);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;babel-core：如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块。&lt;/li&gt;
      &lt;li&gt;babel-polyfill&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;与其他工具的配合
    &lt;ul&gt;
      &lt;li&gt;ESLint：用于静态检查代码的语法和风格&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  安装
  $ npm install --save-dev eslint babel-eslint
  配置 .eslint
  {
    &quot;parser&quot;: &quot;babel-eslint&quot;,
    &quot;rules&quot;: {...}
  }
  package.json之中，加入相应的scripts脚本 &quot;lint&quot;: &quot;eslint my-files.js&quot;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;Mocha：一个测试框架&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;heading-工作原理&quot;&gt;工作原理&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;解析：将代码字符串解析成抽象语法树
    &lt;ul&gt;
      &lt;li&gt;分词：将整个代码字符串分割成语法单元数组&lt;/li&gt;
      &lt;li&gt;语义分析&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;变换：对抽象语法树进行变换操作&lt;/li&gt;
  &lt;li&gt;再建：根据变换后的抽象语法树再生成代码字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-深入理解&quot;&gt;深入理解&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Plugin：转换的执行者&lt;/li&gt;
  &lt;li&gt;Preset：转换规则的集合&lt;/li&gt;
  &lt;li&gt;在饿了么大前端的一些实践
    &lt;ul&gt;
      &lt;li&gt;无痕埋点&lt;/li&gt;
      &lt;li&gt;错误日志收集&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Dada</name><email>hujingdada@126.com</email></author><category term="Babel" /><summary type="html">Babel的功能非常纯粹，以字符串的形式将源代码传给它，它就会返回一段新的代码字符串，既不会运行你的代码，也不会将多个代码打包到一起，只是个编译器，输入语言是ES6+，编译目标语言是ES5。</summary></entry><entry><title type="html">React学习笔记</title><link href="http://localhost:4000/blog/2018/03/27/react/" rel="alternate" type="text/html" title="React学习笔记" /><published>2018-03-27T07:00:00+08:00</published><updated>2018-03-27T07:00:00+08:00</updated><id>http://localhost:4000/blog/2018/03/27/react</id><content type="html" xml:base="http://localhost:4000/blog/2018/03/27/react/">&lt;h1 id=&quot;heading-模块化&quot;&gt;模块化&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;RequireJS: 模块加载器，基于AMD规范;&lt;/li&gt;
  &lt;li&gt;browserify: 基于CommonJS，服务端nodejs自带工具，使用require和module.exports构建项目;&lt;/li&gt;
  &lt;li&gt;webpack: 前端模块打包工具，JS、CSS及其他所有模块管理;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;heading-webpack&quot;&gt;webpack&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;webpack.config.js 配置入口和输出&lt;/li&gt;
  &lt;li&gt;code spliting（代码拆分） 异步加载代码块，而不是简单的打包成一个大文件;&lt;/li&gt;
  &lt;li&gt;静态分析&lt;/li&gt;
  &lt;li&gt;模块热替换（hot module replacement） webpack-dev-server –hot&lt;/li&gt;
  &lt;li&gt;loader: css-loader、style-loader、jsx-loader&lt;/li&gt;
  &lt;li&gt;插件plugin: HtmlWebpackPlugin、EnvironmentPlugin、BannerPlugin&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;heading-react基础&quot;&gt;React基础&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;JSX
    &lt;ul&gt;
      &lt;li&gt;JSX(JavaScript XML)是js内定义的一套XML语法，可以解析出目标js代码,颠覆传统js写法；&lt;/li&gt;
      &lt;li&gt;不能直接在浏览器中使用，需要JSXTransformer编译成React.CreateElement方法；&lt;/li&gt;
      &lt;li&gt;webpack+babel搭建完整的开发环境&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Virtual DOM&lt;/li&gt;
  &lt;li&gt;组件&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;工具: webpack、babel、ESLint&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;虚拟DOM
    &lt;ul&gt;
      &lt;li&gt;虚拟元素&lt;/li&gt;
      &lt;li&gt;比较差异&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;组件化开发
    &lt;ul&gt;
      &lt;li&gt;props属性&lt;/li&gt;
      &lt;li&gt;state状态&lt;/li&gt;
      &lt;li&gt;组件的生命周期&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;heading-flux架构&quot;&gt;Flux架构&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;单向数据流
    &lt;ul&gt;
      &lt;li&gt;Action：描述一个行为的对象&lt;/li&gt;
      &lt;li&gt;Dispatcher：信息分拨中心，dispatch方法执行一个action，rejister方法注册回调处理store的内容&lt;/li&gt;
      &lt;li&gt;Store：处理完成之后，emit方法发送change广播，告知store已经发生了变化&lt;/li&gt;
      &lt;li&gt;View：监听change事件，调用setState来更新UI&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;heading-redux&quot;&gt;Redux&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;三大特性
    &lt;ul&gt;
      &lt;li&gt;单一数据源：整个应用的state存储在一个JS对象中，即store&lt;/li&gt;
      &lt;li&gt;state是只读的：不能在state上面直接修改数据，唯一的方法就是触发action&lt;/li&gt;
      &lt;li&gt;使用纯函数执行修改：reducer是纯函数，接受先前的state和action，输出新的state&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数据流
    &lt;ul&gt;
      &lt;li&gt;单向数据流，可以预测JavaScript状态容器&lt;/li&gt;
      &lt;li&gt;middleware中间件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;heading-react源码学习&quot;&gt;React源码学习&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;ReactElement&lt;/li&gt;
  &lt;li&gt;ReactComponent&lt;/li&gt;
  &lt;li&gt;ReactClass&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Dada</name><email>hujingdada@126.com</email></author><category term="React" /><summary type="html">模块化 RequireJS: 模块加载器，基于AMD规范; browserify: 基于CommonJS，服务端nodejs自带工具，使用require和module.exports构建项目; webpack: 前端模块打包工具，JS、CSS及其他所有模块管理;</summary></entry><entry><title type="html">前端面试</title><link href="http://localhost:4000/blog/2017/05/30/front-interview/" rel="alternate" type="text/html" title="前端面试" /><published>2017-05-30T07:00:00+08:00</published><updated>2017-05-30T07:00:00+08:00</updated><id>http://localhost:4000/blog/2017/05/30/front-interview</id><content type="html" xml:base="http://localhost:4000/blog/2017/05/30/front-interview/">&lt;h1 id=&quot;heading-regexp&quot;&gt;RegExp&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var expression = /pattern /flags&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;特殊标志（flag）：g 全局模式；i 不区分大小写；m 多行模式；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;匹配模式（pattern）&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/2017/mian1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;去掉空格、回车、制表符&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;)&lt;/code&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;(\s*)&lt;/code&gt;表示连续空格的字符串、&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt;表示以开始、&lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt;表示以结尾；&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;jquery&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;$.trim()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;heading-jquery&quot;&gt;JQuery&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Ready&lt;/li&gt;
  &lt;li&gt;插件&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;heading-跨域处理&quot;&gt;跨域处理&lt;/h1&gt;

&lt;h1 id=&quot;heading-http请求状态码&quot;&gt;HTTP请求、状态码&lt;/h1&gt;

&lt;h1 id=&quot;heading-性能优化&quot;&gt;性能优化&lt;/h1&gt;

&lt;h1 id=&quot;heading-json&quot;&gt;JSON&lt;/h1&gt;

&lt;h1 id=&quot;heading-兼容性问题&quot;&gt;兼容性问题&lt;/h1&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;heading-图片延迟加载&quot;&gt;图片延迟加载&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;原理：页面可见区域以下的图片先不加载，等到用户向下滚动到图片位置时，再进行加载。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Js原生方法&lt;/p&gt;

    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;imgs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementsByTagName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'img'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 获取视口高度与滚动条的偏移量&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;lazyload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;scrollTop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pageYOffset&lt;/span&gt; 
                &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;documentElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;scrollTop&lt;/span&gt; 
                &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;scrollTop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;viewportSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerHeight&lt;/span&gt; 
                &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;documentElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;clientHeight&lt;/span&gt; 
                &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;clientHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;imgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;scrollTop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;viewportSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;imgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;offsetTop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                    &lt;span class=&quot;nx&quot;&gt;imgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;imgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getAttribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'loadpic'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}}}&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;setInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lazyload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/script&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;jQuery插件lazyload&lt;/p&gt;

    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;img.lazy&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lazyload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;placeholder&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;img/grey.gif&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// placeholder值为某一图片路径.此图片用来占据将要加载的图片的位置,待图片加载时,占位图则会隐藏&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;fadeIn&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 载入使用何种效show(直接显示),fadeIn(淡入),slideDown(下拉)等,常用fadeIn&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;threshold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// threshold,值为数字,代表页面高度.如设置为200,表示滚动条在离目标位置还有200的高度时就开始加载图片,可以做到不让用户察觉&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'click'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 事件触发时才加载，值click(点击),mouseover(鼠标划过),sporty(运动的),foobar(…).可以实现鼠标莫过或点击图片才开始加载&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;#container&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 对某容器中的图片实现效果,值为某容器.lazyload默认在拉动浏览器滚动条时生效,这个参数可以让你在拉动某DIV的滚动条时依次加载其中的图片&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;failurelimit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//值为数字.lazyload默认在找到第一张不在可见区域里的图片时则不再继续加载,但当HTML容器混乱的时候可能出现可见区域内图片并没加载出来的情况,failurelimit意在加载N张可见区域外的图片,以避免出现这个问题.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;heading-二维码扫描后跳转&quot;&gt;二维码扫描后跳转&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;微信登录的二维码实际上是将一个URL转换成二维码的形式，而通过微信客户端扫码后，无非就是打开了这个url, 我捕捉到的微信二维码的url为&lt;code class=&quot;highlighter-rouge&quot;&gt;https://login.weixin.qq.com/l/YdmTu30I5A==&lt;/code&gt; ，这个url里的&lt;code class=&quot;highlighter-rouge&quot;&gt;YdmTu30I5A==&lt;/code&gt;代表的是本次会话的唯一ID, 这个有点儿类似浏览器里的session id，通过这个ID,微信就能定向将确认结果反馈到网页上。&lt;/li&gt;
  &lt;li&gt;服务器收到了登录信息和sessionID后就可以确认两件事：一是用来确认登录的客户端的用户是验证过的；二是通过session ID服务器知道将反馈结果推送到哪个网页。&lt;/li&gt;
  &lt;li&gt;web实时推送技术，使用推送技术可以节约服务器端和客户端的资源，可以稳定地推送和接收任何消息。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;heading-前端路由&quot;&gt;前端路由&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;路由是根据不同的 url 地址展示不同的内容或页面，前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。&lt;/li&gt;
  &lt;li&gt;优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户&lt;/li&gt;
  &lt;li&gt;缺点：使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存；单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置。&lt;/li&gt;
  &lt;li&gt;原理：当 url 的 hash 发生变化时，触发 hashchange 注册的回调，回调中去进行不同的操作，进行不同的内容的展示。&lt;/li&gt;
  &lt;li&gt;后端路由：每跳转到不同的URL，都是重新访问服务端，然后服务端返回页面，页面也可以是服务端获取数据，然后和模板组合，返回HTML，也可以是直接返回模板HTML，然后由前端JS再去请求数据，使用前端模板和数据进行组合，生成想要的HTML。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;heading-函数声明&quot;&gt;函数声明&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;var aaa=function(){…}：var 方式定义的函数，不能先调用函数，后声明，只能先声明函数，然后调用。&lt;/li&gt;
  &lt;li&gt;function aaa(){…}：function方式定义函数可以先调用，后声明。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;heading-手写盒子模型中&quot;&gt;手写盒子模型中&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;获取盒子内子节点的class样式，盒子内节点的类型不可知&lt;img src=&quot;/assets/images/2017/mian2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;heading-js底层实现原理&quot;&gt;JS底层实现原理&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;ECMAScript（核心）：JavaScript 语言基础；规定了 JavaScript 脚本的核心语法，如 数据类型、关键字、保留字、运算符、对象和语句等，它不属于任何浏览器。&lt;/li&gt;
  &lt;li&gt;DOM（文档对象模型）：规定了访问HTML和XML的接口；“ Document Object Model ”的缩写，简称“ 文件对象模型 ”，由W3C制定规范。定义了 JavaScript 操作 HTML 文档的接口，提供了访问 HTML 文档（如body、form、div、textarea等）的途径以及操作方法。&lt;/li&gt;
  &lt;li&gt;BOM（浏览器对象模型）：提供了独立于内容而在浏览器窗口之间进行交互的对象和方法。Browser Object Model ”的缩写，简称“ 浏览器对象模型 ”。BOM 定义了 JavaScript 操作浏览器的接口，提供了访问某些功能（如浏览器窗口大小、版本信息、浏览历史记录等）的途径以及操作方法。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Dada</name><email>hujingdada@126.com</email></author><category term="Interview" /><summary type="html">RegExp var expression = /pattern /flags 特殊标志（flag）：g 全局模式；i 不区分大小写；m 多行模式； 匹配模式（pattern）</summary></entry><entry><title type="html">JS进阶之ES6</title><link href="http://localhost:4000/blog/2017/05/29/es6/" rel="alternate" type="text/html" title="JS进阶之ES6" /><published>2017-05-29T07:00:00+08:00</published><updated>2017-05-29T07:00:00+08:00</updated><id>http://localhost:4000/blog/2017/05/29/es6</id><content type="html" xml:base="http://localhost:4000/blog/2017/05/29/es6/">&lt;h1 id=&quot;heading-ecmascript-2015es6的十大特征&quot;&gt;ECMAScript 2015（ES6）的十大特征&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;https://www.jianshu.com/p/287e0bb867ae&lt;/li&gt;
  &lt;li&gt;默认参数：&lt;code class=&quot;highlighter-rouge&quot;&gt;var link = function(height = 50, color = 'red', url = 'http://azat.co') {...}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;模板对象：&lt;code class=&quot;highlighter-rouge&quot;&gt;var name = 'Your name is ${first} ${last}.' &lt;/code&gt;; 反引号&lt;/li&gt;
  &lt;li&gt;多行字符串：反引号&lt;/li&gt;
  &lt;li&gt;解构赋值：自动解析数组或对象中的值，不用以对象的方式返回。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增强的对象字面量：实现继承，可以直接在对象字面量里面定义原型，不用再用function 关键字。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/2017/es1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;箭头函数：箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定，完全修复了this的指向，this总是指向词法作用域。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Promises&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/2017/es2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;异步方法调用中，往往会出现回调函数一环扣一环的情况。这种情况导致了回调金字塔问题的出现。不仅代码写起来费劲又不美观，而且问题复杂的时候，阅读代码的人也难以理解。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;三种状态：Fulfilled成功、Rejected失败、Pending为 Promise 对象实例创建时候的初始状态，待执行；&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/2017/es3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;ajax操作Promise化，可以实现链式使用。避免了传统的只能使用回调的麻烦。&lt;/li&gt;
  &lt;li&gt;Promise实现异步任务顺序执行&lt;/li&gt;
  &lt;li&gt;Promise实现异步任务并行执行&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;顺序执行效率低，并行执行但是需要所有的数据加载完成才能开始渲染，并行加载顺序渲染。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/2017/es4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/2017/es5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第一步，加载了story.json的数据；第二步，把数据转换成JSON格式；第三步，把JSON数据打印出来。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/2017/es6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/2017/es7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/2017/es8.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;块级作用域
    &lt;ul&gt;
      &lt;li&gt;let声明的变量只在块级有效。let没有‘变量提升’的特性，而却有‘暂时性死区（temporal dead zone）’的特性。&lt;/li&gt;
      &lt;li&gt;const命令与let命令一样，声明的变量，其作用域都是块级。所以const遵循的规则与let相差无二，只是，const是用来声明恒定变量的。且用const声明恒定变量，声明的同时就必须赋值，否则会报错。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;类
    &lt;ul&gt;
      &lt;li&gt;类的所有实例共享一个原型对象。&lt;/li&gt;
      &lt;li&gt;不存在变量提升&lt;/li&gt;
      &lt;li&gt;私有方法添加下划线&lt;/li&gt;
      &lt;li&gt;类的方法内部如果含有this，它默认指向类的实例&lt;/li&gt;
      &lt;li&gt;继承extends，子类必须在constructor方法中调用super方法，否则新建实例时会报错。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;模块
    &lt;ul&gt;
      &lt;li&gt;JS是解释型语言，边加载边运行，后续脚本运行时，这些脚本所依赖的一切必须已经加载完毕；JS脚本加载时会阻塞浏览器，如果加载的JS很多很大，浏览器会卡住，带来很差的用户体验；通过调整script标签顺序可以修改JS模块之间的依赖，然而当模块很多时，这种做法就不可用了。&lt;/li&gt;
      &lt;li&gt;AMD模块（RequireJS）、CommonJS模块（Node.js）、CMD(SeaJS)&lt;/li&gt;
      &lt;li&gt;导出export&lt;/li&gt;
      &lt;li&gt;
        &lt;h2 id=&quot;heading-导入import&quot;&gt;导入import&lt;/h2&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-es7拓展&quot;&gt;ES7拓展&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;求幂运算符（**）&lt;/li&gt;
  &lt;li&gt;Array.prototype.includes()方法&lt;/li&gt;
  &lt;li&gt;函数作用域中严格模式的变更&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;heading-es8拓展&quot;&gt;ES8拓展&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Object.entries 和 Object.values&lt;/li&gt;
  &lt;li&gt;String.prototype.padStart / String.prototype.padEnd&lt;/li&gt;
  &lt;li&gt;Object.getOwnPropertyDeors&lt;/li&gt;
  &lt;li&gt;异步函数(Async functions)&lt;/li&gt;
  &lt;li&gt;共享内存与原子化(atomics)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Dada</name><email>hujingdada@126.com</email></author><category term="ES6" /><summary type="html">ECMAScript 2015（ES6）的十大特征 https://www.jianshu.com/p/287e0bb867ae 默认参数：var link = function(height = 50, color = 'red', url = 'http://azat.co') {...} 模板对象：var name = 'Your name is ${first} ${last}.' ; 反引号 多行字符串：反引号 解构赋值：自动解析数组或对象中的值，不用以对象的方式返回。 增强的对象字面量：实现继承，可以直接在对象字面量里面定义原型，不用再用function 关键字。</summary></entry><entry><title type="html">前端开发流程</title><link href="http://localhost:4000/blog/2017/05/28/front-dev/" rel="alternate" type="text/html" title="前端开发流程" /><published>2017-05-28T07:00:00+08:00</published><updated>2017-05-28T07:00:00+08:00</updated><id>http://localhost:4000/blog/2017/05/28/front-dev</id><content type="html" xml:base="http://localhost:4000/blog/2017/05/28/front-dev/">&lt;h1 id=&quot;heading-开发流程&quot;&gt;开发流程&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Front-end Integrated Solution（前端集成解决方案）&lt;/li&gt;
  &lt;li&gt;规范与设计&lt;/li&gt;
  &lt;li&gt;技术选型
    &lt;ul&gt;
      &lt;li&gt;选择前端模块化框架（seajs, requirejs, …）&lt;/li&gt;
      &lt;li&gt;选择前端基础库（jquery, tangram, …）&lt;/li&gt;
      &lt;li&gt;选择模板语言（php, smarty, …）&lt;/li&gt;
      &lt;li&gt;选择模板插件（xss修复）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;自动化与拆分
    &lt;ul&gt;
      &lt;li&gt;选择或开发自动化工具（打包，压缩，校验）&lt;/li&gt;
      &lt;li&gt;将系统拆分为几个子系统，以便大团队并行开发&lt;/li&gt;
      &lt;li&gt;适当调整框架以适应工具产出&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;性能优化&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-前后端分离与协同&quot;&gt;前后端分离与协同&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;一种是前端先写一个静态页面，写好后，让后端去套模板。静态页面可以本地开发，也无需考虑业务逻辑只需要实现View即可。不足是还需要后端套模板，这些前端代码后端需要浏览一遍，以免出错。&lt;/li&gt;
  &lt;li&gt;另一种协作模式是，前端直接去写模板，这样做的问题在于，前端编写过程中很依赖与后端环境，如果当后端没写完的情况下，前端几乎没法干活。&lt;/li&gt;
  &lt;li&gt;中间件，基于NodeJS的前后端分离&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-页面优化&quot;&gt;页面优化&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。&lt;/li&gt;
  &lt;li&gt;从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。&lt;/li&gt;
  &lt;li&gt;前端优化的途径有很多，按粒度大致可以分为两类，第一类是页面级别的优化，例如HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等;第二类则是代码级别的优化，例如Javascript中的DOM操作优化、CSS选择符优化、图片优化以及HTML结构优化等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-html语义化&quot;&gt;HTML语义化&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-ajax&quot;&gt;AJAX&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签来调用服务器提供的js脚本。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-模块化&quot;&gt;模块化&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;解决命名冲突（YUI ）、文件依赖（Sea.js）&lt;/li&gt;
  &lt;li&gt;数据模块的加载&lt;/li&gt;
  &lt;li&gt;解析模块的层次依赖关系&lt;/li&gt;
  &lt;li&gt;添加事件机制，优化管理代码&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Dada</name><email>hujingdada@126.com</email></author><category term="Develop" /><summary type="html">开发流程 Front-end Integrated Solution（前端集成解决方案） 规范与设计 技术选型 选择前端模块化框架（seajs, requirejs, …） 选择前端基础库（jquery, tangram, …） 选择模板语言（php, smarty, …） 选择模板插件（xss修复） 自动化与拆分 选择或开发自动化工具（打包，压缩，校验） 将系统拆分为几个子系统，以便大团队并行开发 适当调整框架以适应工具产出 性能优化</summary></entry><entry><title type="html">前端模型</title><link href="http://localhost:4000/blog/2017/05/27/front-model/" rel="alternate" type="text/html" title="前端模型" /><published>2017-05-27T07:00:00+08:00</published><updated>2017-05-27T07:00:00+08:00</updated><id>http://localhost:4000/blog/2017/05/27/front-model</id><content type="html" xml:base="http://localhost:4000/blog/2017/05/27/front-model/">&lt;h1 id=&quot;heading-工作模式&quot;&gt;工作模式&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;图形界面的应用程序提供给用户可视化的操作界面，这个界面提供给数据和信息。&lt;/li&gt;
  &lt;li&gt;用户输入行为（键盘，鼠标等）会执行一些业务逻辑，可能会导致对应用程序数据的变更，数据的变更自然需要用户界面的同步变更以提供最准确的信息。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;View不仅要响应用户操作的业务逻辑，而且要同步Model的变更。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/2017/M1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;heading-mvc&quot;&gt;MVC&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;把应用程序分成View、Model层，还额外的加了一个Controller层，它的职责就是专门管理应用程序的业务逻辑。&lt;/li&gt;
  &lt;li&gt;用户的对View操作以后，View捕获到这个操作，会把处理的权利交移给Controller（Pass calls）；Controller接着会执行相关的业务逻辑，这些业务逻辑可能需要对Model进行相应的操作；当Model变更了以后，会通过观察者模式（Observer Pattern）通知View；View通过观察者模式收到Model变更的消息以后，会向Model请求最新的数据，然后重新更新界面。
    &lt;ul&gt;
      &lt;li&gt;把业务逻辑全部分离到Controller中，模块化程度高。当业务逻辑变更的时候，不需要变更View和Model，只需要Controller换成另外一个Controller就行了（Swappable Controller）。观察者模式可以做到多视图同时更新。&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Controller测试困难。因为视图同步操作是由View自己执行，而View只能在有UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，Controller业务逻辑的正确性是无法验证的：Controller更新Model的时候，无法对View的更新操作进行断言。View无法组件化。View是强依赖特定的Model的，如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的Domain Model是不一样的。&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/images/2017/M2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;heading-mvp&quot;&gt;MVP&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;MVP打破了View原来对于Model的依赖，其余的依赖关系和MVC模式一致。&lt;/li&gt;
  &lt;li&gt;用户对View的操作都会从View交移给Presenter。Presenter同样的会执行相应的业务逻辑，并且对Model进行相应的操作；而这时候Model也是通过观察者模式把自己变更的消息传递出去，但是是传给Presenter而不是View。Presenter获取到Model变更的消息以后，通过View提供的接口更新界面。
    &lt;ul&gt;
      &lt;li&gt;便于测试。Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过模拟一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter业务逻辑的正确性；View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务逻辑完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做高度可复用的View组件。&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Presenter中除了业务逻辑以外，还有大量的View-&amp;gt;Model，Model-&amp;gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/images/2017/M3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;heading-mvvm&quot;&gt;MVVM&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;可以看作是一种特殊的MVP（Passive View）模式，或者说是对MVP模式的一种改良。
    &lt;ul&gt;
      &lt;li&gt;MVVM的调用关系和MVP一样。但是，在ViewModel当中会有一个叫Binder，或者是Data-binding engine的东西。以前全部由Presenter负责的View和Model之间数据同步操作交由给Binder处理。你只需要在View的模版语法当中，指令式地声明View上的显示的内容是和Model的哪一块数据绑定的。当ViewModel对进行Model更新的时候，Binder会自动把数据更新到View上去，当用户对View进行操作（例如表单输入），Binder也会自动把数据更新到Model上去。这种方式称为：Two-way data-binding，双向数据绑定。可以简单而不恰当地理解为一个模版引擎，但是会根据数据变更实时渲染。&lt;/li&gt;
      &lt;li&gt;MVVM把View和Model的同步逻辑自动化了。以前Presenter负责的View和Model同步不再手动地进行操作，而是交由框架所提供的Binder进行负责。只需要告诉Binder，View显示的数据对应的是Model哪一部分即可。&lt;/li&gt;
      &lt;li&gt;提高可维护性。解决了MVP大量的手动View和Model同步的问题，提供双向绑定机制。提高了代码的可维护性。简化测试。因为同步逻辑是交由Binder做的，View跟着Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;过于简单的图形界面不适用，或说牛刀杀鸡。对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的。&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/images/2017/M4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;heading-spa&quot;&gt;SPA&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;single-page application，它将所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript 和 CSS。&lt;/li&gt;
  &lt;li&gt;一旦页面加载完成了，SPA不会因为用户的操作而进行页面的重新加载或跳转。而是利用 JavaScript 动态的变换HTML的内（采用的是div切换显示和隐藏），从而实现UI与用户的交互。由于避免了页面的重新加载，SPA 可以提供较为流畅的用户体验。&lt;/li&gt;
  &lt;li&gt;得益于ajax，我们可以实现无跳转刷新，又多亏了浏览器的histroy机制，我们用hash的变化从而可以实现推动界面变化。
    &lt;ul&gt;
      &lt;li&gt;通过hashchange事件，我们可以监视#后面字符，一旦发生改变，就会触发此事件，也是大家常说的URL 的锚部分。&lt;/li&gt;
      &lt;li&gt;局部刷新，这属于AJAX（阿贾克斯）的内容&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;heading-前端模板&quot;&gt;前端模板&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;将 HTML 代码（View 层）和 JS 代码（Controller 层）混杂在了一起，UI 与逻辑代码混杂在一起，阅读起来会非常吃力。一旦业务复杂起来，或者多人维护的情况下，几乎会失控。而且如果需要拼接的 HTML 代码里有很多引号的话（比如有大量的 href 属性，src 属性），那么就非常容易出错了（这样干过的应该深有体会）。这样一来，如果前端需要改 HTML 代码，只需要改模板即可。这样做的优点很明显，前端 UI和逻辑代码不再混杂，阅读体验良好，改动起来也方便了许多。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/2017/M5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/2017/m6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Dada</name><email>hujingdada@126.com</email></author><category term="Model" /><summary type="html">工作模式 图形界面的应用程序提供给用户可视化的操作界面，这个界面提供给数据和信息。 用户输入行为（键盘，鼠标等）会执行一些业务逻辑，可能会导致对应用程序数据的变更，数据的变更自然需要用户界面的同步变更以提供最准确的信息。 View不仅要响应用户操作的业务逻辑，而且要同步Model的变更。</summary></entry><entry><title type="html">前端性能优化</title><link href="http://localhost:4000/blog/2017/05/26/front-performance/" rel="alternate" type="text/html" title="前端性能优化" /><published>2017-05-26T07:00:00+08:00</published><updated>2017-05-26T07:00:00+08:00</updated><id>http://localhost:4000/blog/2017/05/26/front-performance</id><content type="html" xml:base="http://localhost:4000/blog/2017/05/26/front-performance/">&lt;h1 id=&quot;heading-基本概念&quot;&gt;基本概念&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验；&lt;/li&gt;
  &lt;li&gt;从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-优化途径&quot;&gt;优化途径&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;按粒度大致可以分为两类，第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等；&lt;/li&gt;
  &lt;li&gt;第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。&lt;/li&gt;
  &lt;li&gt;减少 HTTP请求数：一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。
    &lt;ul&gt;
      &lt;li&gt;页面简单，不需要过多的修饰；&lt;/li&gt;
      &lt;li&gt;合理设置 HTTP缓存：被缓存资源的请求服务器是 304响应，只有 Header没有Body ，可以节省带宽&lt;/li&gt;
      &lt;li&gt;资源合并与压缩：如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。另外， CSS、 Javascript、Image 都可以用相应的工具进行压缩，压缩后往往能省下不少空间。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;将外部脚本置底（将脚本内容在页面信息内容加载后再加载）
    &lt;ul&gt;
      &lt;li&gt;外链脚本在加载时却会阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;异步执行 inline脚本(其实原理和上面是一样，保证脚本在页面内容后面加载。)&lt;/li&gt;
  &lt;li&gt;将 CSS放在 HEAD中
    &lt;ul&gt;
      &lt;li&gt;如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，用户体验比较糟糕。&lt;/li&gt;
      &lt;li&gt;除此之外，有些浏览器会在 CSS下载完成后才开始渲染页面，如果 CSS放在靠下的位置则会导致浏览器将渲染时间推迟。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DOM 操作优化：DOM操作应该是脚本中最耗性能的一类操作，例如增加、修改、删除 DOM元素或者对 DOM集合进行操作。
    &lt;ul&gt;
      &lt;li&gt;需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。即使不转换为数组，也请尽可能少的访问它，例如在遍历的时候可以将 length属性、成员保存到局部变量后再使用局部变量。每次使用时都要重新执行查询得到结果；&lt;/li&gt;
      &lt;li&gt;Reflow &amp;amp; Repaint：不要一条一条地修改 DOM 的样式；&lt;/li&gt;
      &lt;li&gt;慎用 with、避免使用 eval和 Function、减少作用域链、查找数据访问。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CSS选择符&lt;/li&gt;
  &lt;li&gt;HTML&lt;/li&gt;
  &lt;li&gt;Image压缩&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Dada</name><email>hujingdada@126.com</email></author><category term="Performance" /><summary type="html">基本概念 从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验； 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。</summary></entry><entry><title type="html">浏览器机制</title><link href="http://localhost:4000/blog/2017/05/25/browser/" rel="alternate" type="text/html" title="浏览器机制" /><published>2017-05-25T07:00:00+08:00</published><updated>2017-05-25T07:00:00+08:00</updated><id>http://localhost:4000/blog/2017/05/25/browser</id><content type="html" xml:base="http://localhost:4000/blog/2017/05/25/browser/">&lt;h1 id=&quot;heading-什么叫加载下载&quot;&gt;什么叫加载（下载）？&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;加载就是下载html文档的过程，本质是下载&lt;/li&gt;
  &lt;li&gt;了解浏览器如何进行加载，我们可以在引用外部样式css文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-什么叫渲染显示&quot;&gt;什么叫渲染（显示）？&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;渲染是浏览器根据html文档把html元素显示的过程&lt;/li&gt;
  &lt;li&gt;了解浏览器如何进行渲染，我们可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-什么叫解析解释&quot;&gt;什么叫解析（解释）？&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;下载后的JavaScript文件，和css文件需要对Dom树进行修改，叫做解析过程，对javascript很多时候解析过程就是执行过程。&lt;/li&gt;
  &lt;li&gt;了解浏览器如何进行解析，明白渲染的过程，我们在设置元素属性，编写js文件时，可以减少“重绘”“重新布局”的消耗。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这三个过程在实际进行的时候又不是完全独立，而是会有交叉。会造成一边加载，一边解析，一边渲染的工作现象。&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;heading-用户访问网页都发生了什么&quot;&gt;用户访问网页都发生了什么&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;DNS服务器（域名解析系统）会根据用户提供的域名查找对应的IP地址；&lt;/li&gt;
  &lt;li&gt;客户端会向与对应IP地址的网络服务器建立TCP连接并发送一个http请求；&lt;/li&gt;
  &lt;li&gt;网络服务器解析请求，并发送请求给数据库服务器，数据库服务器将请求的资源返回给网络服务器；&lt;/li&gt;
  &lt;li&gt;网络服务器解析数据，并生成html文件，放入http response中，返回给浏览器；&lt;/li&gt;
  &lt;li&gt;浏览器解析http response，下载html文件，以及html文件内包含的外部引用文件，及文件内涉及的图片或者多媒体文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-浏览器渲染页面和解析加载页面机制&quot;&gt;浏览器渲染页面和解析加载页面机制&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。&lt;/li&gt;
  &lt;li&gt;浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点；&lt;/li&gt;
  &lt;li&gt;将CSS解析成 CSS Rule Tree 。&lt;/li&gt;
  &lt;li&gt;根据DOM树和CSSOM来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。&lt;/li&gt;
  &lt;li&gt;有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。&lt;/li&gt;
  &lt;li&gt;再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。&lt;/li&gt;
  &lt;li&gt;上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-回流与重绘&quot;&gt;回流与重绘&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Reflow（回流）浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。&lt;/li&gt;
  &lt;li&gt;Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。Reflow要比Repaint更花费时间，也就更影响性能。所以在写代码的时候，要尽量避免过多的Reflow。&lt;/li&gt;
  &lt;li&gt;reflow的原因：
    &lt;ul&gt;
      &lt;li&gt;页面初始化的时候；&lt;/li&gt;
      &lt;li&gt;操作DOM时；&lt;/li&gt;
      &lt;li&gt;某些元素的尺寸变了；&lt;/li&gt;
      &lt;li&gt;如果 CSS 的属性发生变化了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;减少 reflow/repaint
    &lt;ul&gt;
      &lt;li&gt;不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。&lt;/li&gt;
      &lt;li&gt;不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。&lt;/li&gt;
  &lt;li&gt;千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-html页面加载和解析流程&quot;&gt;HTML页面加载和解析流程&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；&lt;/li&gt;
  &lt;li&gt;浏览器开始载入html代码，发现&lt;code class=&quot;highlighter-rouge&quot;&gt;＜head＞&lt;/code&gt;标签内有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;＜link＞&lt;/code&gt;标签引用外部CSS文件；&lt;/li&gt;
  &lt;li&gt;浏览器又发出CSS文件的请求，服务器返回这个CSS文件；&lt;/li&gt;
  &lt;li&gt;浏览器继续载入html中&lt;code class=&quot;highlighter-rouge&quot;&gt;＜body＞&lt;/code&gt;部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；&lt;/li&gt;
  &lt;li&gt;浏览器在代码中发现一个&lt;code class=&quot;highlighter-rouge&quot;&gt;＜img＞&lt;/code&gt;标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；&lt;/li&gt;
  &lt;li&gt;服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；&lt;/li&gt;
  &lt;li&gt;浏览器发现了一个包含一行JavaScript代码的&lt;code class=&quot;highlighter-rouge&quot;&gt;＜script＞&lt;/code&gt;标签，赶快运行它；&lt;/li&gt;
  &lt;li&gt;JavaScript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个&lt;code class=&quot;highlighter-rouge&quot;&gt;＜div＞ （style.display=”none”）&lt;/code&gt;。突然少了这么一个元素，浏览器不得不重新渲染这部分代码；&lt;/li&gt;
  &lt;li&gt;终于等到了&lt;code class=&quot;highlighter-rouge&quot;&gt;＜/html＞&lt;/code&gt;的到来，浏览器泪流满面……&lt;/li&gt;
  &lt;li&gt;等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下&lt;code class=&quot;highlighter-rouge&quot;&gt;＜link＞&lt;/code&gt;标签的CSS路径；&lt;/li&gt;
  &lt;li&gt;浏览器召集了在座的各位&lt;code class=&quot;highlighter-rouge&quot;&gt;＜div＞＜span＞＜ul＞＜li＞&lt;/code&gt;们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-css文件解析&quot;&gt;CSS文件解析&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;CSS选择符是从右到左进行匹配的。从右到左！&lt;/li&gt;
  &lt;li&gt;所以，&lt;code class=&quot;highlighter-rouge&quot;&gt;#nav li&lt;/code&gt; 我们以为这是一条很简单的规则，秒秒钟就能匹配到想要的元素，但是，但是，但是，是从右往左匹配啊，所以，会去找所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;li&lt;/code&gt;，然后再去确定它的父元素是不是&lt;code class=&quot;highlighter-rouge&quot;&gt;#nav&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;因此，写css的时候需要注意：
    &lt;ul&gt;
      &lt;li&gt;dom深度尽量浅&lt;/li&gt;
      &lt;li&gt;减少inline javascript、css的数量。&lt;/li&gt;
      &lt;li&gt;使用现代合法的css属性&lt;/li&gt;
      &lt;li&gt;不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。&lt;/li&gt;
      &lt;li&gt;避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;&lt;code class=&quot;highlighter-rouge&quot;&gt;#tp p{}&lt;/code&gt; 子选择符：&lt;code class=&quot;highlighter-rouge&quot;&gt;#tp&amp;gt;p{}&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;避免使用通配符，举一个例子，&lt;code class=&quot;highlighter-rouge&quot;&gt;.mod .hd *{font-size:14px;}&lt;/code&gt; 根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配&lt;code class=&quot;highlighter-rouge&quot;&gt;.hd&lt;/code&gt;（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配&lt;code class=&quot;highlighter-rouge&quot;&gt;.mod&lt;/code&gt;,这样的性能耗费可想而知.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-javascript的加载和执行的特点&quot;&gt;Javascript的加载和执行的特点&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;载入后马上执行；&lt;/li&gt;
  &lt;li&gt;执行时会阻塞页面后续的内容（包括页面的渲染、其它资源的下载）。原因：因为浏览器需要一个稳定的DOM树结构，而JS中很有可能有 代码直接改变了DOM树结构，比如使用 document.write 或 appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修 改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现。&lt;/li&gt;
  &lt;li&gt;减少 JavaScript 对性能的影响的方法
    &lt;ul&gt;
      &lt;li&gt;将所有的script标签放到页面底部，也就是body闭合标签之前，这能确保在脚本执行前页面已经完成了DOM树渲染。&lt;/li&gt;
      &lt;li&gt;尽可能地合并脚本。页面中的script标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。&lt;/li&gt;
      &lt;li&gt;采用无阻塞下载 JavaScript 脚本的方法：等页面完成加载后，再加载js代码。也就是，在window.load事件发出后开始下载代码。带defer属性的script标签，动态脚本元素。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Dada</name><email>hujingdada@126.com</email></author><category term="Browser" /><summary type="html">什么叫加载（下载）？ 加载就是下载html文档的过程，本质是下载 了解浏览器如何进行加载，我们可以在引用外部样式css文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。</summary></entry><entry><title type="html">前端框架初体验</title><link href="http://localhost:4000/blog/2017/05/24/front-frame/" rel="alternate" type="text/html" title="前端框架初体验" /><published>2017-05-24T07:00:00+08:00</published><updated>2017-05-24T07:00:00+08:00</updated><id>http://localhost:4000/blog/2017/05/24/front-frame</id><content type="html" xml:base="http://localhost:4000/blog/2017/05/24/front-frame/">&lt;h1 id=&quot;heading-nodejs&quot;&gt;Node.js&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;并不是一门新的语言，与Java，PHP开发语言的平台也是不相同的，虽然他是JavaScript但是它并不是JavaScript的框架。&lt;/li&gt;
  &lt;li&gt;nodejs是让JavaScript运行在服务器端的开发平台。当一种事务在一个领域独孤求败的时候就会想着进入另外一个领域，JavaScript已经在近几年已经一统的前端的江湖，所以已经开始进入服务端的领域。&lt;/li&gt;
  &lt;li&gt;Node.js是基于Chrome JavaScript运行时建立的一个平台，使用C++编写的，实际上它是对Google Chrome V8引擎进行了封装，它主要用于创建快速的、可扩展的网络应用。&lt;/li&gt;
  &lt;li&gt;Node.js采用事件驱动和非阻塞I/O模型，使其变得轻微和高效，非常适合构建运行在分布式设备的数据密集型实时应用。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;heading-grunt&quot;&gt;Grunt&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;自动化。&lt;/li&gt;
  &lt;li&gt;对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting等，自动化工具可以减轻你的劳动，简化你的工作。&lt;/li&gt;
  &lt;li&gt;当你在 Gruntfile 文件正确配置好了任务，任务运行器就会自动帮你或你的小组完成大部分无聊的工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;heading-模块化工具&quot;&gt;模块化工具&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;requirejs、seajs&lt;/li&gt;
  &lt;li&gt;将一些属性比较类似和行为比较类似的内容放在同一个js文件里面，把这个js文件称为模块，了每个js文件只关注与自身有关的事情，让每个js文件各行其职；&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;MVC：veiw ( html + css + js )写静态页面 css、js、img及效果；controller ( 专注于实现服务和逻辑控制的层面叫做控制器 )监听页面中请求和事件，处理请求和事件；向model请求数据，得到数据后绑定到页面；model ( 数据变量&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;ajax从服务端取回的数据 )对外提供一些数据&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;命名冲突、文件依赖&lt;img src=&quot;/assets/images/2017/k1.jpg&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;/assets/images/2017/k2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;heading-类库&quot;&gt;类库&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;解决的是代码或者是模块级别的复用或者对复杂度的封装问题，例如将一个解决复杂问题的功能模块封装成一个函数，提供一个简单的接口。&lt;/li&gt;
  &lt;li&gt;它是一种工具，它提供了很多封装好的方法，用与不用取决于我们自身，即使用了也不会影响我们的代码结构。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-框架&quot;&gt;框架&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;对模式级别的复用和对程序组织的规范。这里的模式是指比如MVC，为了实现M和V的解耦，把复杂的耦合关系由经常变化的业务代码转移到不经常变化的框架内部消化。&lt;/li&gt;
  &lt;li&gt;是面向一个领域来提供一套解决方案，提高开发效率，如果我们选择了使用某框架，就应该遵循该框架所规定的规则。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-区别是&quot;&gt;区别是&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;JQuery以DOM操作为中心，框架，准确来说是MVC框架，是以模型（model）为中心，而DOM操作是附加的。所以，以模型为中心最终达到的目的是带来一整套工作流程的变更，使得后台工程师可以编写前端的模型代码，把后台与前端打通，交互设计师处理UI跟模型的互动关系，UI设计师可以专注、无障碍的处理HTML源码，把它们以界面模板的形式提交给交互工程师。这一整套协作机制能大大提高开发效率。使用MVC框架使得前端任务更好的被解耦。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;heading-bootstrapui框架&quot;&gt;BootStrap：UI框架&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;响应式布局：响应式web布局是让用户通过不同尺寸的浏览器都可以获得良好视觉的一种方法。通过CSS3 Media Queries（媒体（设备）查询），媒体查询是让页面内容在不同的媒体环境下运行时可以展示不同的样式（这个样式当然是由我们来书写规定的）。@media是CSS3中规定的属性，它可以实现针对不同媒体设备来设置不同的样式的目的。而且就算是在同一设备中它也可以在你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。Bootstrap主要用到min-width、max-width，以及and语法，用于在不同的分辨率下设置不同的CSS样式。&lt;/li&gt;
  &lt;li&gt;移动设备优先：在html文件中head区域加入这样的一个meta标签，name=“viewpoint”是指这个标签对移动设备生效，content中width=device-width是指宽度为设备宽度，initial-scale=1意思是初始缩放比例为1.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;栅格系统：将一个页面可以拆分成多个区块来理解，而正是这些区块共同构成了真个页面的布局。根据不同的屏幕尺寸情况，调整这些区块的排版，就可以实现响应式设计。另外，屏幕宽度较大的时候，区块倾向于水平分布，而屏幕宽度较小的时候，区块倾向于竖直堆叠。 栅格样式库一般是这样做的：将页面划分为若干等宽的列（column），然后推荐你通过等宽列来创建响应式的页面区块。 Bootstrap把它的栅格放在CSS这个分类下，并称它为Gird system。默认分为12列。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/2017/k3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Dada</name><email>hujingdada@126.com</email></author><category term="Framework" /><summary type="html">Node.js 并不是一门新的语言，与Java，PHP开发语言的平台也是不相同的，虽然他是JavaScript但是它并不是JavaScript的框架。 nodejs是让JavaScript运行在服务器端的开发平台。当一种事务在一个领域独孤求败的时候就会想着进入另外一个领域，JavaScript已经在近几年已经一统的前端的江湖，所以已经开始进入服务端的领域。 Node.js是基于Chrome JavaScript运行时建立的一个平台，使用C++编写的，实际上它是对Google Chrome V8引擎进行了封装，它主要用于创建快速的、可扩展的网络应用。 Node.js采用事件驱动和非阻塞I/O模型，使其变得轻微和高效，非常适合构建运行在分布式设备的数据密集型实时应用。</summary></entry></feed>